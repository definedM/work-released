local HTTPServ = game:GetService("HttpService")
local RepStorage = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local LP = plrs.LocalPlayer
local LPGui = LP:WaitForChild("PlayerGui")

local BuildUi = LPGui:WaitForChild("MainGUI"):WaitForChild("ScreenGui")
local Blocks = workspace:WaitForChild("Blocks")
local Rems = RepStorage.Sockets
local EditRems = Rems.Edit
local NoVipColrs, MaterialIds, ShapeIds, SizeIds = nil, {}, {}, {}

repeat task.wait(0.3) until LPGui.Loading.Enabled == false

getgenv().Rank = function()
	return LPGui:WaitForChild("WorldMenuGui"):WaitForChild("WorldMenu"):WaitForChild("TabsFrame"):WaitForChild("Players"):WaitForChild(LP.UserId):WaitForChild("PermFrame"):WaitForChild("PermName").Text
end

if not game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LP.UserId, 3756285) then 
	getgenv().IsVip = false -- all getgenvs is for your uses if you wanted to include something
	local colrFoldr = nil
	NoVipColrs = {}
	for i, v in pairs(BuildUi:GetChildren()) do
		if v.Name == 'Color' and v:FindFirstChild("Content") and v.Content:FindFirstChild("Palette") then
			
			colrFoldr = v.Content.Palette:WaitForChild("Content")
			
		end
	end
	
	for i, v in pairs(colrFoldr:GetChildren()) do
		if v:IsA('ImageButton') then
			table.insert(NoVipColrs, v.BackgroundColor.Color)
		end
	end
else
	getgenv().IsVip = true
end

do --get materials
	local function sortUI(Stuff, Class)
		local Tab = {}
		for i, v in pairs(Stuff:GetChildren()) do
			if v:IsA(Class) then
				Tab[i] = v.Text --there might be a better way to do this through script RepStorage.Modules.Client.Building, same for color
			end
		end
		return Tab
		--[[
		table.sort(Tab, function(v1, v2)
			if not v2 then print'v2 is empty' return false end
			print(v1,v2)
			return v1[2] < v2[2] --issue is that ui position is all {0, 0} {0, 0} due to UIlistlayout usage
		end)
		]]
	end

	local matFolder
	local function getBuildUi()
		print'begin'
		for i, v in pairs(BuildUi:GetDescendants()) do
			if v:IsA("TextButton") and v.Text == "Plastic" then
				return v.Parent
			end
		end
	end
	matFolder = getBuildUi()
	MaterialIds = sortUI(matFolder, "TextButton")

	
end

getgenv().blocklimit = 45 --donot set this over 50(might get kicked), but yu are free to chang it to wuteva
getgenv().blockqueue = 0

local function UnNil(Value, Default)
	if Value ~= nil and typeof(Value) ~= 'nil' then
		return Value
	end
	return Default or false
end

local function GetNearestColor(R, G, B)
	R = UnNil(R, 0)
	G = UnNil(G, 0)
	B = UnNil(B, 0)
	
	if typeof(R) == 'Color3' then
		B = R.B
		G = R.G
		R = R.R
	elseif typeof(R) == 'table' then
		B = R[2]
		G = R[3]
		R = R[1]
	end
	
	if R >= 1 and G >= 1 and B >= 1 then 
		R, G, B = R*255, G*255, B*255
	end

	local Colors = Color3.fromRGB(R, G, B)
	R, G, B, Colors = Colors.R, Colors.G, Colors.B, nil
	if UnNil(NoVipColrs, false) then
		local BestColor, Difference = NoVipColrs[1], math.huge
		for i = 1, #NoVipColrs do
			local colr = NoVipColrs[i]
			local newDiff = math.sqrt((R-colr.R)^2 + (B-colr.B)^2 + (G-colr.G)^2)
			
			if newDiff < Difference then
				Difference = newDiff
				BestColor = colr
			end
		end
		print(BestColor)
		return Color3.new(BestColor.R, BestColor.G, BestColor.B)
	else
		return Color3.new(R, G, B)
	end
end

local function MaterialToNum(item, returnEnum) --doesnt take in instances
	if typeof(item) == 'EnumItem' then
		item = tostring(item):split(".")[3]
	elseif typeof(item) == 'number' then
        if returnEnum then
		    item = Enum.MaterialIds[item]
        else
            item = MaterialIds[item]
        end
		item = UnNil(item, 'Number out of table max/min: '..#MaterialIds)
	end

	return UnNil(item, 1)
end

local function ShapeToNum(item)
    
    return item
end

local function SizeToNum(item)

end

local function CreateProps(propTable, Obj) --creates a template for properties of a basic obj. obj parameter is for copying obj props
	local props = {
		['Reflectance'] = 0,
		['CanCollide'] = true,
		['Color'] =  Color3.new(0, 0, 0),
		['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --default value is wierd
		['Transparency'] = 0,
		['Light'] = 0,
		['Material'] = UnNil(MaterialId, MaterialToNum(Obj.Material)),
		['Shape'] = 1,
		['Size'] = 1
	}

	if Obj then --obj only useful for paint command and cloning
		--convert all object proerties into the prop table as a new default
		local PointLight = Obj:FindFirstChild("PointLight")
		props = {
			['Reflectance'] = Obj.Reflectance,
			['CanCollide'] = Obj.CanCollide,
			['Color'] =  Color3.fromRGB(Obj.Color.R, Obj.Color.G, Obj.Color.B),
			['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --default value is wierd
			['Transparency'] = Obj.Transparency,
			['Light'] = 0,
			['Material'] = UnNil(MaterialId, MaterialToNum(Obj.Material)),
			['Shape'] = 1,
			['Size'] = 1
		}
		if PointLight then
			props['Light'] = Obj.PointLight.Range
			props['LightColor'] = Color3.fromRGB(PointLight.Color.R, PointLight.Color.G, PointLight.Color.B) --default value is wierd
		end
	end

	if typeof(propTable) == 'table' then 
		for i, v in pairs(propTable) do
			props[i] = v
		end
	end

	return props
end

local function WaitInQueue()
    while getgenv().blockqueue >= getgenv().blocklimit do
        task.wait(0.2)
    end
    getgenv().blockqueue += 1
    return
end

local function QueueOver()
	task.wait(1.05)
	getgenv().blockqueue -= 1
	return
end

local function ConvertPos(givenPos, ToBlockate)--if its a blockate position, set toblockate to true
	givenPos = UnNil(givenPos, Vector3.new(0,0,0))
	if ToBlockate then
		givenPos = math.floor(givenPos/4+0.5)
	else
		givenPos = givenPos*4
	end
	return givenPos
end

local function FindObjAtPos(Pos) 
	local obj
	for i, v in pairs(Blocks:GetChildren()) do
		if v:IsA("Part") and v.Position == Pos then
			obj = v
		end
	end
	return obj
end

local function TeleTo(Obj, Yoffset)
	offset = UnNil(Yoffset, 0)
	if typeof(Obj) == 'Instance' then
		LP.Character.HumanoidRootPart.CFrame = CFrame.new(Obj.Position) * CFrame.new(0, offset, 0)
	end
end


local BMod = {}

function BMod.UnNil(...) return UnNil(...) end
function BMod.WaitInQueue(...) return WaitInQueue(...) end
function BMod.QueueOver(...) return QueueOver() end
function BMod.ConvertPos(...) return ConvertPos(...) end
function BMod.GetNearestColor(...) return GetNearestColor(...) end
function BMod.FindObjAtPos(...) return FindObjAtPos(...) end
function BMod.MaterialToNum(...) return MaterialToNum(...) end
function BMod.ShapeToNum(...) return ShapeToNum(...) end
function BMod.SizeToNum(...) return SizeToNum(...) end
function BMod.CreateProps(...) return CreateProps(...) end
function BMod.TeleTo(...) return TeleTo(...) end
--the above ar automaticaly done for you if you just use default roblox stuff, its just duplicated here if you need it for whatevr. plus i wil organiz this later

function BMod.ClearWorld(DisableWarn)
	local function BreakAll()
		if getgenv().Rank == "Owner" then
			game:GetService("ReplicatedStorage").Sockets.World.LoadTemplate:FireServer("Scratch")
		

		end
	end
	
	if not UnNil(DisableWarn, false) then BreakAll() return end
	local S = Instance.new("ScreenGui", LP.PlayerGui)
	local F = Instance.new("Frame", S)
	local B = Instance.new("TextButton", F)
	B.Size = UDim2.new(1, 0, 1, 0)
	B.TextScaled = true
	B.Text = "Are you sure you want to clear? This includes all blocks and stats. (if yes, click. if not, wait 5 seconds)"
	F.Position = UDim2.new(0.6, 0, 0.2, 0)
	F.Size = UDim2.new(0, 150, 0, 120)

	B.MouseButton1Click:Connect(function()
		BreakAll()
		S:Destroy()
	end)
	
	pcall(function()
		LP.Character.Humanoid.Died:Connect(function()
			S:Destroy()
			return
		end)
	end)

	task.wait(5)
	S:Destroy()
	return
end

function BMod.place(Vec3, propTable) --color properties require the GetNearestColor(R, G, B) function or an actual Color3.new(value) that you own. Also, vec3 is in terms of blockate's placement system (use convertpos)
	WaitInQueue()
	spawn(function()
		local x, y, z = tostring(math.floor(Vec3.X+0.5)), tostring(math.floor(Vec3.Y+0.5)), tostring(math.floor(Vec3.Z+0.5))
		local pos = x..' '..y..' '..z.."/0" --this number is the orientation (possible values 4, 16, 0, 20) but i cant giv a shid about implemeting it
		local args = {
			[1] = pos,
			[2] = {
				["Reflectance"] = 0,
				["CanCollide"] = true,
				["Color"] = Color3.new(0,0,0),
				["LightColor"] = Color3.new(0,0,0),
				["Transparency"] = 0,
				["Light"] = 0,
				["Material"] = 1,
				["Shape"] = 1,
				["Size"] = 1
			}
		}
		if typeof(propTable) == 'table' then 
			for i, v in pairs(propTable) do
				args[2][i] = v
			end
		end

	    EditRems.Place:InvokeServer(unpack(args))
		QueueOver()
	end)
end

function BMod.delete(InstOrPos) --provide either instance or position
	WaitInQueue()

	spawn(function()
		if typeof(InstOrPos) == 'Vector3' then InstOrPos = FindObjAtPos(InstOrPos, true) end
		EditRems.Delete:FireServer(InstOrPos)
		QueueOver()
	end)
end

--function BMod.paint(ObjTab, BrushThick, propTable) --very good for mass changes to world, only included color, material, and brush change since others cant change (and dont forget to use GetNearestColor() for color changes)
		
function BMod.paint(ObjTab, color3, MaterialId, BrushThick) --very good for mass changes to world, only included color, material, and brush change since others cant change (and dont forget to use GetNearestColor() for color changes)
		WaitInQueue()
		print"working"
		spawn(function()
			if typeof(ObjTab) == 'table' then
				for i = 1, #ObjTab do
					if typeof(ObjTab[1]) == 'Vector3' then
						ObjTab[i] = FindObjAtPos(Obj, true)
						ObjTab[i] = UnNil(ObjTab[i])
					end
				end
			elseif typeof(ObjTab) == 'Vector3' then
				ObjTab = FindObjAtPos(Obj, true)
				ObjTab = {UnNil(ObjTab)}
			elseif typeof(ObjTab) == 'Instance' then
				ObjTab = {UnNil(ObjTab)}
			else
				warn("no object")
				return
			end
			print(typeof(ObjTab))
			
			local args = {}
			
			local function AddArgs(Obj)
				print(Obj.Name, color3, MaterialId)
				--for som reason it doesnt go past this
				local args2 = {
					[1] = Obj, --add numbers to all for less conufiosn
					[2] = Obj,
					[3] = {
						['Reflectance'] = 1,
						['CanCollide'] = true,
						['Color'] =  color3,
						['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --cant paint a block with light, gotta leave these values for rmote to work
						['Transparency'] = 1,
						['Light'] = 0,
						['Material'] = MaterialId,
						['Shape'] = 1,
						['Size'] = 1
					},
					[4] = UnNil(BrushThick, 1), -- brush thickness
					[5] = {
						['Color'] = true,
						['Material'] = true,
					}    
				}
				args[#args+1] = args2
			end
	
			for i = 1, #ObjTab do
				if UnNil(ObjTab) then
					AddArgs(ObjTab[i])
				end    
			end
			
			args = {args}
			
			for i, v in pairs(args[1]) do 
				print(i,v[3]["Color"])
			end
			print'painting'
			EditRems.Paint:FireServer(unpack(args))
			QueueOver()
		end)
	--temporary solution
	--[[
	WaitInQueue()
	print"working"
	spawn(function()
		if typeof(ObjTab) == 'table' then
			for i = 1, #ObjTab do
				if typeof(ObjTab[1]) == 'Vector3' then
					ObjTab[i] = FindObjAtPos(Obj, true)
					ObjTab[i] = UnNil(ObjTab[i])
				end
			end
		elseif typeof(ObjTab) == 'Vector3' then
			ObjTab = FindObjAtPos(Obj, true)
			ObjTab = {UnNil(ObjTab)}
		elseif typeof(ObjTab) == 'Instance' then
			ObjTab = {UnNil(ObjTab)}
		else
			warn("no object")
			return
		end
		print(typeof(ObjTab))
		
		local args = {}
		
		local function AddArgs(Obj)
			print(Obj.Name)
			local args2 = {
                [1] = Obj, --add numbers to all for less conufiosn
                [2] = Obj,
                [3] = {
                    ['Reflectance'] = 0,
                    ['CanCollide'] = true,
                    ['Color'] =  color3,
                    ['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --cant paint a block with light, gotta leave these values for rmote to work
                    ['Transparency'] = 0,
                    ['Light'] = 0,
                    ['Material'] = UnNil(MaterialId, MaterialToNum(Obj.Material)),
                    ['Shape'] = 1,
                    ['Size'] = 1
                },
                [4] = UnNil(BrushThick, 1), -- brush thickness
                [5] = {
                    ['Color'] = true,
                    ['Material'] = true,
                }
            }
			for i = 1, #args2 do 
				print(args[i])
				args[#args+1] = args2[i]
			end
		end

		for i = 1, #ObjTab do
			if UnNil(ObjTab) then
				AddArgs(ObjTab[i])
			end	
		end
		
		for i, v in pairs(args) do 
			print(i,v)
		end
		print'painting'
		EditRems.Paint:FireServer(unpack(args))
		QueueOver()
	end)
	]]
end

--[[
function BMod.Pixelate() --needs to be an image id
	local Image = require(somemodulelol)

	local brightnessArray = {}
	math.randomseed(tick())
	for i = 1, 100 do
		for j = 1, 100 do
			table.insert(brightnessArray, math.max(0, (math.noise(i/100, j/100) + 0.5) * 255))
		end
	end

	local img = Image.fromMonochrome(100, 100, brightnessArray)
	for i = 1, img.height do
		for j = 1, img.width do
			local index = (i - 1) * img.width + j
			local pixel = img.pixels[index]
			
			local p = Instance.new("Part")
			p.Anchored = true
			p.Size = Vector3.new(1, 1, 1)
			p.CFrame = CFrame.new(i, 10, j)
			p.Color = Color3.fromRGB(pixel, pixel, pixel)
			p.Material = Enum.Material.SmoothPlastic
			p.Parent = workspace
		end
		wait()
	end
end
]]

function BMod.callCommand(commandName, params)
	Rems.Command:InvokeServer('!'..commandName.." "..params)
end

function BMod.GamepassSerivce(itemID, bluxPrice, func)
	--working on later
end

function BMod.MarkPart()
	--working on later
end

function BMod.Touched(GivnObj, EventName) --they should make their own as there will be part initializer option
	if typeof(GivnObj) ~= 'Instance' then print('Item must be an instance') return end
	local Event = Instance.new("BindableEvent")
	Event.Name = EventName
	EventName = nil
	local function CreateTouch(obj, Evnt)
		obj.Touched:Connect(function(obj)
			Evnt:Fire(obj)
		end)
	end
	coroutine.wrap(CreateTouch(GivnObj, Event))()
end 

function BMod.SaveWorld(filename, Exclusions) --only saves block type, placement, and texture
    filename = UnNil(filename, "BlockateSave.txt")
    writefile(filename)
    local file = {['Blocks'] = {}}

	for i, part in pairs(Blocks:GetChildren()) do
		file.Blocks[#file+1] = CreateProps(part)
		--[[
		local Pos = ConvertPos(part.Position, false)
        local Mat = MaterialToNum(part)
        local Shape = ShapeToNum(part)
        local Col = GetNearestColor(part)
        file[#file+1] = {Pos, Mat, Shape, Col}
		]]
	end
	--[[
	for i, v in pairs(LP.leaderstats:GetChildren()) do
		
	end
    ]]

    writefile(filename, HTTPServ:JSONEncode(file))
end

function BMod.LoadWorld(filename, Exclusions)
    local file = HTTPServ:JSONDecode(readfile(filename))
    if not filename or not file then warn("Provide a filename (or file may be corupted)") return end
    filename = nil

    for _, Props in pairs(file.Blocks) do
        local Pos = Props[1]
		local Mat = Props[2]
		local Shape = Props[3]
		local Col = Props[4]
        BMod.place(Pos, { })
    end
end
--ok i swer i stop making functions and start making them work

return BMod
--[[
Contributors
wrty (no github brueh)
araknala

]]
