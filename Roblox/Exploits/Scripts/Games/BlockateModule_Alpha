local HTTPServ = game:GetService("HttpService")
local RepStorage = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local LP = plrs.LocalPlayer
local LPGui = LP:WaitForChild("PlayerGui")

local BuildUi = LPGui:WaitForChild("MainGUI"):WaitForChild("ScreenGui")
local Blocks = workspace:WaitForChild("Blocks")
local Rems = RepStorage.Sockets
local EditRems = Rems.Edit
local NoVipColrs, MaterialIds, ShapeIds = nil, {}, {}
local SizeIds = { --dont change order
	Vector3.new(4, 4, 4),
	Vector3.new(4, 2, 4),
	Vector3.new(2, 4, 4),
	Vector3.new(4, 4, 2),
	Vector3.new(2, 2, 2),
	Vector3.new(2, 4, 2),
	Vector3.new(4, 2, 2),
	Vector3.new(2, 2, 4)
}

local RotationIds = {
	Vector3.new(0, 0, 1),
	Vector3.new(0, 0, 2),
	Vector3.new(0, 0, 3),
	
	Vector3.new(2, 0, 2),
	Vector3.new(2, 0, 3),
	Vector3.new(2, 0, 0),
	Vector3.new(2, 0, 1),

	Vector3.new(1, 0, 3),
	Vector3.new(1, 0, 0),	
	Vector3.new(1, 0, 1),
	Vector3.new(1, 0, 2),

	Vector3.new(3, 0, 3),
	Vector3.new(3, 0, 0),
	Vector3.new(3, 0, 1),
	Vector3.new(3, 0, 2),
		
	Vector3.new(0, 3, 0),
	Vector3.new(3, 3, 0),
	Vector3.new(2, 3, 0),	
	Vector3.new(1, 3, 0),

	Vector3.new(0, 1, 0),
	Vector3.new(1, 1, 0),	
	Vector3.new(2, 1, 0),
	Vector3.new(3, 1, 0),
}

repeat task.wait(0.3) until LPGui.Loading.Enabled == false

getgenv().getRank = function()
	return LPGui:WaitForChild("WorldMenuGui"):WaitForChild("WorldMenu"):WaitForChild("TabsFrame"):WaitForChild("Players"):WaitForChild(LP.UserId):WaitForChild("PermFrame"):WaitForChild("PermName").Text
end

if not game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LP.UserId, 3756285) then 
	getgenv().IsVip = false -- all getgenvs is for your uses if you wanted to include something
	local colrFoldr = nil
	NoVipColrs = {}
	for i, v in pairs(BuildUi:GetChildren()) do
		if v.Name == 'Color' and v:FindFirstChild("Content") and v.Content:FindFirstChild("Palette") then
			colrFoldr = v.Content.Palette:WaitForChild("Content")
		end
	end
	
	for i, v in pairs(colrFoldr:GetChildren()) do
		if v:IsA('ImageButton') then
			table.insert(NoVipColrs, v.BackgroundColor.Color)
		end
	end
else
	getgenv().IsVip = true
end

do --get properties' info
	local function sortUI(Folder, Class)
		local Tab = {}
		for i, v in pairs(Folder:GetChildren()) do
			if v:IsA(Class or "TextButton") then
				Tab[#Tab + 1] = v.Text --there might be a better way to do this through script RepStorage.Modules.Client.Building, same for color
			end
		end
		return Tab
	end

	local matFolder
	local function getFolder()
		print'begin'
		local KWs = {"Plastic", "Block", "Full"}
		local all = {} --folder
		for i, v in pairs(BuildUi:GetChildren()) do
			if #all ~= 3 and v.Name == "Dropdown" then
				local Button = v.Dropdown.Content:FindFirstChildOfClass("TextButton")
				local Index = table.find(KWs, Button.Text)
				if Index then
					all[Index] = Button.Parent
				end
			end
		end
		return all
	end
	local Folders = getFolder()
	--[[for _, v in pairs(Folders) do for _, v2 in pairs(v:GetChildren()) do if v2:IsA("TextButton") then print(v2.Text) end end end --Test Tables]]
	matFolder, shapeFolder, sizeFolder = Folders[1], Folders[2], Folders[3]
	MaterialIds = sortUI(matFolder)
	ShapeIds = sortUI(shapeFolder)
	SizeIds = sortUI(sizeFolder)
end

local function UnNil(Value, Default) --uhhh
	if Value ~= nil and typeof(Value) ~= 'nil' then
		return Value
	end
	return Default or false
end

local function MaterialToNum(item, returnEnum) --doesnt take in instances
	if typeof(item) == "Instance" then
		item = item.Material
	end
	if typeof(item) == 'EnumItem' then
		item = tostring(item):split(".")[3]
	elseif typeof(item) == 'number' then
        if returnEnum then
		    item = Enum.MaterialIds[item]
        else
            item = MaterialIds[item]
        end
		item = UnNil(item, 'Number out of table max/min: '..#MaterialIds)
	end

	return UnNil(item, 1)
end

local function ShapeToNum(item)
    return table.find(ShapeIds, item.Name)
end

local function SizeToNum(item)
	local size = item.Size
	return table.find(SizeIds, size)
end

local function GetLightRangeAndColor(item)
	local PointLight, range, color = item:FindFirstChild("PointLight"), 0, Color3.new(0.94902,0.952941,0.952941)
	if not PointLight then return range, color end
	range, color = PointLight.Range, Color3.fromRGB(PointLight.Color.R, PointLight.Color.G, PointLight.Color.B)
	return range, color
end

local function FindObjAtPos(Pos) 
	local obj
	for i, v in pairs(Blocks:GetChildren()) do
		if v:IsA("Part") and v.Position == Pos then
			obj = v
		end
	end
	return obj
end

local function TeleTo(ObjPos, Vec3Offset) --[Obj] can be a part or Vector3, [Vec3Offset] can be Vector3 OR Y offset
	if typeof(Vec3Offset) == 'number' then Vec3Offset = Vector3.new(0, Vec3Offset, 0) end
	
	if typeof(ObjPos) == 'Instance' then
		ObjPos = Obj.Position
	end
	
	LP.Character.PrimaryPart.CFrame = CFrame.new(ObjPos.X+Vec3Offset+X, ObjPos.Y+Vec3Offset.Y, ObjPos.Z+Vec3Offset.Z)
end

local function CFToPosStr(givenCF, ToRoblox, AddSigns)--if its a blockate position (they use strings), set ToRoblox to true to extract a roblox CFrame from it
	local givenOrient, output --output will be returned(CFrame if ToRoblox, String if not)
	if typeof(givenCF) == "Instance" then
		givenOrient = givenCF.Orientation
		givenCF = givenCF.CFrame
	elseif typeof(givenCF) == "Vector3" then
		--givenCF = CFrame.new(givenCF)
		givenOrient = Vector3.new(0,0,0)
	end

	if not ToRoblox then --makes a CFrame(or vector3) into a string to use in the BMod.place() function
		local posTab = {}
		givenPos = {givenCF.X/4, givenCF.Y/4, givenCF.Z/4}

		for i, v in pairs(givenPos) do
			local num, sign = math.floor(v+0.5), '-'
			if num > v then
				sign = '+'
			end
			posTab[i] = tostring(num)..sign
		end
		posTab[1], posTab[2] = posTab[1]..' ', posTab[2]..' '

		if not givenOrient then
			local x,y,z = givenCF:ToOrientation()
			givenOrient = Vector3.new(math.deg(x),math.deg(y),math.deg(z))
		end
		local function toRightAngle(degr)
			return math.floor((degr+360)%360/90+0.5)
		end
		givenOrient = toRightAngle(givenOrient.X), toRightAngle(givenOrient.Y), toRightAngle(givenOrient.Z)
		local id = RotationIds[table.find(RotationIds, givenOrient)] or '0'

		posTab[3] = posTab[3]..'/'..tostring(id) --work on later
		output, posTab = table.concat(posTab), nil
	else --this turns output into a real Vector3
		local posTab = givenCF:split(' ')
		local data = posTab[3]:split('/')
		posTab[3], posTab[4], data = data[1], data[2], nil

		for i = 1, 3 do
			N = posTab[i]
			local add = 0

			if string.find(N, '-') then
				add = -2
			elseif string.find(N, '+') then
				add = 2
			end
			posTab[i] = N*4 + add
		end
		local rot = RotationIds[posTab[4]]
		posTab[4], rot = nil, Vector3.new(rot.X*90, rot.Y*90, rot.Z*90)
		
		output = CFrame.new(posTab[1], posTab[2], posTab[3]) * CFrame.Angles(math.rad(rot.X), math.rad(rot.Y), math.rad(rot.Z))
	end
	return output
end

local function safePosString(String, Size)
	if not Size then Size = Vector3.new(4,4,4) end
	local segments, Size = String:split(" "), {Size.X, Size.Y, Size.Z}
	local Z = segments[3]:split('/') --break the 3rd arg into 2 things
	segments[3] = Z[1]

	for i = 1, #segments do
		seg = segments[i]
		if Size[i] == 4 then --erase if the size cant use + or -
			if string.find(seg, '[%+%-]', 2) then
				segments[i] = string.sub(seg, 1, seg:len()-1)
			end
		end
	end
	segments[3] = segments[3]..'/'..Z[2] --reapply orientation
	return table.concat(segments, ' ')
end

local function GetNearestObjColor(R, G, B)
	R = UnNil(R, 0)
	G = UnNil(G, 0)
	B = UnNil(B, 0)
	if typeof(R) == 'Instance' then
		R = R.Color
	end

	if typeof(R) == 'Color3' then
		B = R.B
		G = R.G
		R = R.R
	elseif typeof(R) == 'table' then
		B = R[2]
		G = R[3]
		R = R[1]
	end
	
	if R >= 1 and G >= 1 and B >= 1 then 
		R, G, B = R*255, G*255, B*255
	end

	local Colors = Color3.fromRGB(R, G, B)
	R, G, B, Colors = Colors.R, Colors.G, Colors.B, nil
	if UnNil(NoVipColrs, false) then
		local BestColor, Difference = NoVipColrs[1], math.huge
		for i = 1, #NoVipColrs do
			local colr = NoVipColrs[i]
			local newDiff = math.sqrt((R-colr.R)^2 + (B-colr.B)^2 + (G-colr.G)^2)
			
			if newDiff < Difference then
				Difference = newDiff
				BestColor = colr
			end
		end
		return Color3.new(BestColor.R, BestColor.G, BestColor.B)
	else
		return Color3.new(R, G, B)
	end
end

local function CreateProps(propTable, Obj) --creates a template for properties of a basic obj. obj parameter is for copying obj props
	local props = {
		['Reflectance'] = 0,
		['CanCollide'] = true,
		['Color'] =  Color3.new(0, 0, 0),
		['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --default value is wierd
		['Transparency'] = 0,
		['Light'] = 0,
		['Material'] = 1,
		['Shape'] = 1,
		['Size'] = 1
	}

	if Obj then --obj is optional, this just clones the object
		--convert all object proerties and overwrit the prop table as a new default
		local range, color = GetLightRangeAndColor()
		props = {
			['Reflectance'] = Obj.Reflectance,
			['CanCollide'] = Obj.CanCollide,
			['Color'] = GetNearestObjColor(Obj),
			['LightColor'] = color,
			['Transparency'] = Obj.Transparency,
			['Light'] = range,
			['Material'] = MaterialToNum(Obj.Material),
			['Shape'] = ShapeToNum(Obj),
			['Size'] = SizeToNum(Obj)
		}
	end
	--change values to proptable
	if typeof(propTable) == 'table' then 
		for i, v in pairs(propTable) do
			props[i] = v
		end
	end

	return props
end

getgenv().blocklimit = 43 --donot set this over 50(might get kicked), but yu are free to chang it to wuteva
getgenv().blockqueue = 0

local function WaitInQueue()
	if getgenv().blockqueue >= getgenv().blocklimit then
		task.wait(0.5)
	end
    while getgenv().blockqueue >= getgenv().blocklimit do
        task.wait(0.2)
    end
    getgenv().blockqueue += 1
    return
end

local function QueueOver()
	task.wait(1.05)
	getgenv().blockqueue -= 1
	return
end


local BMod = {}

function BMod.UnNil(...) return UnNil(...) end
function BMod.MaterialToNum(...) return MaterialToNum(...) end
function BMod.ShapeToNum(...) return ShapeToNum(...) end
function BMod.SizeToNum(...) return SizeToNum(...) end
function BMod.GetLightRangeAndColor(...) return GetLightRangeAndColor(...) end
function BMod.FindObjAtPos(...) return FindObjAtPos(...) end
function BMod.TeleTo(...) return TeleTo(...) end
function BMod.CFToPosStr(...) return CFToPosStr(...) end
function BMod.safePosString(...) return safePosString(...) end
function BMod.GetNearestObjColor(...) return GetNearestObjColor(...) end
function BMod.CreateProps(...) return CreateProps(...) end
function BMod.WaitInQueue(...) return WaitInQueue(...) end
function BMod.QueueOver(...) return QueueOver() end
--the above ar automaticaly done for you if you just use default roblox stuff, its just duplicated here if you need it for whatevr. plus i wil organiz this later

function BMod.place(PosString, propTable) --color properties require the GetNearestObjColor(R, G, B) function or an actual Color3.new(value) that you own. Also, PosString is in terms of blockate's placement system (use CFToPosStr WITH safePosString OR simply use a CFrame)
	if typeof(PosString) ~= 'string' then
		PosString = CFToPosStr(PosString, false)
	end
	
	if propTable and propTable[Size] then
		PosString = safePosString(PosString, propTable[Size])
	else 
		PosString = safePosString(PosString)
	end
	
	WaitInQueue()
	coroutine.wrap(function()
		local args = {
			[1] = PosString,
			[2] = CreateProps(propTable)
		}
	    EditRems.Place:InvokeServer(unpack(args))
		QueueOver()
		return
	end)()
end

function BMod.delete(InstOrPos) --provide either instance or position
	WaitInQueue()

	coroutine.wrap(function()
		if typeof(InstOrPos) == 'Vector3' then InstOrPos = FindObjAtPos(InstOrPos, true) end
		EditRems.Delete:FireServer(InstOrPos)
		QueueOver()
		return
	end)()
end

function BMod.paint(ObjTab, propTable, BrushThick) --very good for mass changes to world, ONLY color, material, and brush thickness can change
	WaitInQueue()
	coroutine.wrap(function()
		if typeof(ObjTab) == 'table' then
			for i = 1, #ObjTab do
				if typeof(ObjTab[1]) == 'Vector3' then
					ObjTab[i] = FindObjAtPos(Obj, true)
					ObjTab[i] = UnNil(ObjTab[i])
				end
			end
		elseif typeof(ObjTab) == 'Vector3' then
			ObjTab = FindObjAtPos(Obj, true)
			ObjTab = {UnNil(ObjTab)}
		elseif typeof(ObjTab) == 'Instance' then
			ObjTab = {UnNil(ObjTab)}
		else
			warn("no object")
			return
		end
		
		local args = {}
		local propTable = CreateProps(propTable)
		local function AddArgs(Obj)
			--for som reason it doesnt go past this
			local args2 = {
				[1] = Obj, --add numbers to all for less conufiosn
				[2] = Obj,
				[3] = propTable,
				[4] = UnNil(BrushThick, 1), -- brush thickness
				[5] = {
					['Color'] = true,
					['Material'] = true,
				}    
			}
			--CreateProps() can make it smaller
			args[#args+1] = args2
		end

		for i = 1, #ObjTab do
			if UnNil(ObjTab) then
				AddArgs(ObjTab[i])
			end    
		end
		
		args = {args}
		
		for i, v in pairs(args[1]) do 
			print(i,v[3]["Color"])
		end
		EditRems.Paint:FireServer(unpack(args))
		QueueOver()
		return
	end)()
end

function BMod.ClearWorld(deleteStarterblock, DisableWarn)
	local function BreakAll()
		if getgenv().getRank() == "Owner" then
			game:GetService("ReplicatedStorage").Sockets.World.LoadTemplate:FireServer("Scratch")
		else
			for _, obj in pairs(Blocks:GetChildren()) do
				BMod.delete(obj)
			end
		end
		if deleteStarterblock then
			Blocks:WaitForChild("Block", 1)
			if Blocks:FindFirstChild("Block") then
				BMod.delete(Blocks.Block)
			end			
		else
			BMod.place("0 0 0/0", {['Color'] = Color3.new(242, 243, 243)})
		end
	end
	if not UnNil(DisableWarn, false) then BreakAll() return end
	local S = Instance.new("ScreenGui", LP.PlayerGui)
	local F = Instance.new("Frame", S)
	local B = Instance.new("TextButton", F)
	B.Size = UDim2.new(1, 0, 1, 0)
	B.TextScaled = true
	B.Text = "Are you sure you want to clear? This includes all blocks and stats. (if yes, click. if not, wait 5 seconds)"
	F.Position = UDim2.new(0.6, 0, 0.2, 0)
	F.Size = UDim2.new(0, 150, 0, 120)

	B.MouseButton1Click:Connect(function()
		BreakAll()
		S:Destroy()
	end)
	
	pcall(function()
		LP.Character.Humanoid.Died:Connect(function()
			S:Destroy()
			return
		end)
	end)

	task.wait(5)
	S:Destroy()
	return
end

--[[ uhh dont worry about this

function BMod.Pixelate() --needs to be an image id
	local Image = require(somemodulelol)

	local brightnessArray = {}
	math.randomseed(tick())
	for i = 1, 100 do
		for j = 1, 100 do
			table.insert(brightnessArray, math.max(0, (math.noise(i/100, j/100) + 0.5) * 255))
		end
	end

	local img = Image.fromMonochrome(100, 100, brightnessArray)
	for i = 1, img.height do
		for j = 1, img.width do
			local index = (i - 1) * img.width + j
			local pixel = img.pixels[index]
			
			local p = Instance.new("Part")
			p.Anchored = true
			p.Size = Vector3.new(1, 1, 1)
			p.CFrame = CFrame.new(i, 10, j)
			p.Color = Color3.fromRGB(pixel, pixel, pixel)
			p.Material = Enum.Material.SmoothPlastic
			p.Parent = workspace
		end
		wait()
	end
end
]]

function BMod.callCommand(commandName, params)
	Rems.Command:InvokeServer('!'..commandName.." "..params)
end

function BMod.GamepassSerivce(itemID, bluxPrice, func)
	--working on later
end

function BMod.MarkPart() --u can use Part.Touched on the uniquely marked part
	--working on later
end

function BMod.SaveWorld(filename, Exclusions) --only saves block type, placement, and texture
	if not filename then
		local Defaultname = "BlockateSave"
		local i = 0
		repeat
			filename = readfile(Defaultname..i)
		until UnNil(filename, false)
		filename = Defaultname..i..".txt"
	end

    local file = {['Blocks'] = {}}
	print'saving...'
	for i, part in pairs(Blocks:GetChildren()) do
		print(i, part.Name)
		local posStr, Props = CFToPosStr(part.Position), CreateProps(part)
		file.Blocks[#file.Blocks+1] = {posStr, Props} --turn the color3 vals into a number table bc they cant store in json
	end

    writefile(filename..'.json', HTTPServ:JSONEncode(file))
end

function BMod.LoadWorld(filename, Exclusions)
    local file = HTTPServ:JSONDecode(readfile(filename..'.json'))
    if not filename or not file then warn("Provide a filename (or file may be corupted)") return end
    filename = nil

    for _, PropsTab in pairs(file.Blocks) do
        BMod.place(PropsTab[1], PropsTab[2])
    end
end
--ok i swer i stop making functions and start making them work
BMod.SaveWorld("BlockateTestSave")

BMod.ClearWorld()

BMod.LoadWorld("BlockateTestSave")
--[[
for x = 1, 50 do
	for z = 1, 50 do
		BMod.place(Vector3.new(0, math.cosh(x)/math.cosh(z), 0))
	end
end
]]
print'successfully returned'
return BMod
--[[
Contributors
wrty (no github brueh)
araknala

]]
