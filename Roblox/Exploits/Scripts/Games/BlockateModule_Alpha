
local RepStorage = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local LP = plrs.LocalPlayer
local LPGui = LP:WaitForChild("PlayerGui")

local BuildUi = LPGui:WaitForChild("MainGUI"):WaitForChild("ScreenGui")
local Blocks = workspace:WaitForChild("Blocks")
local Rems = RepStorage.Sockets
local EditRems = Rems.Edit
local NoVipColrs, MaterialIds = {}, {}

repeat task.wait(0.2) until LPGui.Loading.Enabled == false

if not game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LP.UserId, 3756285) then 
	
	local colrFoldr
	
	for i, v in pairs(BuildUi:GetChildren()) do
		if v.Name == 'Color' and v:FindFirstChild("Content") and v.Content:FindFirstChild("Palette") then
			
			colrFoldr = v.Content.Palette:WaitForChild("Content")
			
		end
	end
	
	for i, v in pairs(colrFoldr:GetChildren()) do
		if v:IsA('ImageButton') then
			table.insert(NoVipColrs, v.BackgroundColor.Color)
		end
	end
	
end

do --get materials
	local matFolder
	for i, v in pairs(BuildUi:GetDescendants()) do
		if v:IsA("TextButton") and v.Text == "Plastic" then
			matFolder = v.Parent
		end
	end
	
	for i, v in ipairs(matFolder:GetChildren()) do
		if v:IsA("TextButton") then
			MaterialIds[i] = v.Text --there might be a better way to do this through script RepStorage.Modules.Client.Building, same for color
		end
	end
end

getgenv().blocklimit = 45 --donot set this over 50, but yu are free to chang it to wuteva
getgenv().blockqueue = 0

local function UnNil(Value, Default)
	if Value ~= nil then
		return Value
	end
	return Default or false
end

local function GetNearestColor(R, G, B)
	UnNil(R, 0)
	UnNil(G, 0)
	UnNil(B, 0)
	if typeof(R) == 'Color3' then
		R = R.R
		B = R.B
		G = R.G
	elseif typeof(R) == 'table' then
		R = R[1]
		B = R[2]
		G = R[3]
	end
	if R >= 1 and G >= 1 and B >= 1 then 
		R, G, B = R*255, G*255, B*255
	end

	local Colors = Color3.fromRGB(R, G, B)
	R, G, B, Colors = Colors.R, Colors.G, Colors.B, nil
	
	if NoVipColrs then
		local BestColor, Difference = nil, math.huge
		for i = 1, #NoVipColrs do
			local colr = NoVipColrs[i]
			local newDiff = math.sqrt((R-colr.R)^2 + (B-colr.B)^2 + (G-colr.G)^2)
			
			if newDiff < Difference then
				Difference = newDiff
				BestColor = colr
			end
		end
		return Color3.new(BestColor.R, BestColor.G, BestColor.B)
	else
		return Color3.new(R, G, B)
	end
end

local function MaterialToNum(EnumOrString)
	if typeof(materialOrNum) == 'EnumItem' then
		materialOrNum = tostring(materialOrNum):split(".")[3]
	end
	materialOrNum = table.find(MaterialIds, materialOrNum)

	return UnNil(materialOrNum, 0)
end

local function WaitInQueue()
    while getgenv().blockqueue >= getgenv().blocklimit do
        task.wait(0.2)
    end
    getgenv().blockqueue += 1
    task.wait()
    return
end

local function QueueOver()
	task.wait(1.1)
	getgenv().blockqueue -= 1
end

local function ConvertPos(givenPos, ToBlockate)
	UnNil(givenPos, Vector3.new(0,0,0))
	if ToBlockate then
		givenPos = givenPos/4+0.5
		givenPos = Vector3.new(math.floor(givenPos.X+0.5),math.floor(givenPos.Y+0.5),math.floor(givenPos.Z+0.5))
	else
		givenPos = givenPos*4
	end
	return givenPos
end

local function FindObjAtPos(Pos, IsBlockate) 
	local obj
	if IsBlockate then
		Pos = ConvertPos(Pos, true)
	end
	for i, v in pairs(Blocks:GetChildren()) do
		if v:IsA("Part") and v.Position == Pos then
			obj = v
		end
	end
	return obj
end
--[[   	coming later
local function WaitNewObj(props) 
	Blocks.ChildAdded:Connect(function(obj)
		if typeof(props) == 'table' then
			local NotObj = false
			for i, v in pairs(props) do
				if NotObj and obj[i] ~= v then
					NotObj = true
				end		
			end
		else
			return obj
		end
	end)
end
]]

local BMod = {}

function BMod.WaitInQueue(...) return WaitInQueue(...) end
function BMod.QueueOver(...) return QueueOver() end
function BMod.ConvertPos(...) return ConvertPos(...) end
function BMod.GetNearestColor(...) return GetNearestColor(...) end
function BMod.FindObjAtPos(...) return FindObjAtPos() end


--the above ar automaticaly done for you if you just use default roblox stuff, its just duplicated here if you need it for whatevr

function BMod.ClearWorld(DisableWarn)
	local function BreakAll()
		game:GetService("ReplicatedStorage").Sockets.World.LoadTemplate:FireServer("Scratch")
	end
	
	if UnNil(DisableWarn, false) then BreakAll() return end
	local S = Instance.new("ScreenGui", LP.PlayerGui)
	local F = Instance.new("Frame", S)
	local B = Instance.new("TextButton", F)
	B.Size = UDim2.new(1, 0, 1, 0)
	B.TextScaled = true
	B.Text = "Are you sure you want to clear the world? (if yes, click. if not, wait 5 seconds)"
	F.Position = UDim2.new(0.6, 0, 0.2, 0)
	F.Size = UDim2.new(0, 150, 0, 120)

	B.MouseButton1Click:Connect(function()
		BreakAll()
		S:Destroy()
	end)
	
	pcall(function()
		LP.Character.Humanoid.Died:Connect(function()
			S:Destroy()
			return
		end)
	end)
	
	task.wait(5)
	S:Destroy()
	return
end

function BMod.place(x, y, z, propTable)
	WaitInQueue()
	spawn(function()
		local x, y, z = tostring(UnNil(x), 0), tostring(UnNil(y), 0), tostring(UnNil(z), 0)
		local pos = x..' '..y..' '..z.."/0" --this number is the orientation (possible values 4, 16, 0, 20) but i cant giv a shid about implemeting it
		local args = {
			[1] = pos,
			[2] = {
				["Reflectance"] = 0,
				["CanCollide"] = true,
				["Color"] = Color3.new(0,0,0),
				["LightColor"] = Color3.new(0,0,0),
				["Transparency"] = 0,
				["Light"] = 0,
				["Material"] = 1,
				["Shape"] = 1,
				["Size"] = 1
			}
		}
		if typeof(propTable) == 'table' then 
			for i, v in pairs(propTable) do
				args[2][i] = v
			end
		end
	    EditRems.Place:InvokeServer(unpack(args))
	    
		QueueOver()
		return addedObj
	end)
end

function BMod:delete(InstOrPos)
	WaitInQueue()
	local Inst = InstOrPos
	spawn(function()
		if typeof(Inst) == 'Vector3' then Inst = FindObjAtPos(Inst, true) end
		EditRems.Delete:FireServer(Inst)
		QueueOver()
	end)
end


function BMod:paint(color3, MaterialId, BrushThick) --very good for mass changes to world, only included color, material, and brush change since others cant change
	WaitInQueue()
	spawn(function()
		local ObjTab = self
		if typeof(ObjTab) == 'table' then
			for i = 1, #ObjTab do
				if typeof(ObjTab[1]) == 'Vector3' then
					ObjTab[i] = FindObjAtPos(Obj, true)
					ObjTab[i] = UnNil(ObjTab[i])
				end
			end
		elseif typeof(ObjTab) == 'Vector3' then
			ObjTab = FindObjAtPos(Obj, true)
			ObjTab = {UnNil(ObjTab)}
		else
			warn("no object")
			return
		end
		
		local function AddArgs(Obj)
			local args = {
				[1] = Obj, --add numbers to all for less conufiosn
				[2] = Obj,
				[3] = {
					[1] = {
						['Reflectance'] = 0,
						['CanCollide'] = true,
						['Color'] = color3,
						['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --cant paint a block with light, gotta leave these values for rmote to work
						['Transparency'] = 0,
						['Light'] = 0,
						['Material'] = UnNil(MaterialId, GetMaterial(Obj.Material)),
						['Shape'] = 1,
						['Size'] = 1
					},
					UnNil(BrushThick, 1), -- brush thickness
					[1] = {
						['Color'] = true,
						['Material'] = true,
					}
				}		
			}
		end

		for i = 1, #ObjTab do
			if UnNil(ObjTab) then
				AddArgs(ObjTab[i])
			end	
		end
				
		EditRems.Paint:FireServer(unpack(args))
		QueueOver()
	end)
end

--[[
function BMod:PixelateImage() --needs to be an image (thanks to this forum post https://devforum.roblox.com/t/open-source-image-processing/485936 by Auxintic)
	local Image = require(script.Image)

	local brightnessArray = {}
	math.randomseed(tick())
	for i = 1, 100 do
		for j = 1, 100 do
			table.insert(brightnessArray, math.max(0, (math.noise(i/100, j/100) + 0.5) * 255))
		end
	end

	local img = Image.fromMonochrome(100, 100, brightnessArray)
	for i = 1, img.height do
		for j = 1, img.width do
			local index = (i - 1) * img.width + j
			local pixel = img.pixels[index]
			
			local p = Instance.new("Part")
			p.Anchored = true
			p.Size = Vector3.new(1, 1, 1)
			p.CFrame = CFrame.new(i, 10, j)
			p.Color = Color3.fromRGB(pixel, pixel, pixel)
			p.Material = Enum.Material.SmoothPlastic
			p.Parent = workspace
		end
		wait()
	end
end
]]

function BMod.callCommand(commandName, params)
	Rems.Command:InvokeServer('!'..commandName.." "..params)
end

function BMod.GamepassSerivce(itemID, price, func)
	--working on
end

function BMod:Touched(EventName)
	if typeof(self) ~= 'Instance' then print('Item must be an instance') return end
	local Event = Instance.new("BindableEvent")
	Event.Name = EventName
	EventName = nil
	self.Touched:Connect(function(obj)
		Event:Fire(obj)
	end)--could yield script, consider changing
end 

return BMod
