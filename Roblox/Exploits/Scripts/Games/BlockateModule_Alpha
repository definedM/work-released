local RepStorage = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local LP = plrs.LocalPlayer
local LPGui = LP:WaitForChild("PlayerGui")

local BuildUi = LPGui:WaitForChild("MainGUI"):WaitForChild("ScreenGui")
local Blocks = workspace:WaitForChild("Blocks")
local Rems = RepStorage.Sockets
local EditRems = Rems.Edit
local NoVipColrs, MaterialIds = nil, {}

repeat task.wait(0.3) until LPGui.Loading.Enabled == false

getgenv().Rank = LPGui:WaitForChild("WorldMenuGui"):WaitForChild("WorldMenu"):WaitForChild("TabsFrame"):WaitForChild("Players"):WaitForChild(LP.UserId):WaitForChild("PermFrame"):WaitForChild("PermName").Text

if not game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LP.UserId, 3756285) then 
	getgenv().IsVip = false -- for your uses if you wanted to include something
	local colrFoldr = nil
	NoVipColrs = {}
	for i, v in pairs(BuildUi:GetChildren()) do
		if v.Name == 'Color' and v:FindFirstChild("Content") and v.Content:FindFirstChild("Palette") then
			
			colrFoldr = v.Content.Palette:WaitForChild("Content")
			
		end
	end
	
	for i, v in pairs(colrFoldr:GetChildren()) do
		if v:IsA('ImageButton') then
			table.insert(NoVipColrs, v.BackgroundColor.Color)
		end
	end
end

do --get materials
	local matFolder
	for i, v in pairs(BuildUi:GetDescendants()) do
		if v:IsA("TextButton") and v.Text == "Plastic" then
			matFolder = v.Parent
		end
	end
	for i, v in ipairs(matFolder:GetChildren()) do
		if v:IsA("TextButton") then
			MaterialIds[i] = v.Text --there might be a better way to do this through script RepStorage.Modules.Client.Building, same for color
		end
	end
end

getgenv().blocklimit = 45 --donot set this over 50, but yu are free to chang it to wuteva
getgenv().blockqueue = 0

local function UnNil(Value, Default)
	if Value ~= nil and typeof(Value) ~= 'nil' then
		return Value
	end
	return Default or false
end

local function GetNearestColor(R, G, B)
	R = UnNil(R, 0)
	G = UnNil(G, 0)
	B = UnNil(B, 0)
	
	if typeof(R) == 'Color3' then
		B = R.B
		G = R.G
		R = R.R
	elseif typeof(R) == 'table' then
		B = R[2]
		G = R[3]
		R = R[1]
	end
	
	if R >= 1 and G >= 1 and B >= 1 then 
		R, G, B = R*255, G*255, B*255
	end

	local Colors = Color3.fromRGB(R, G, B)
	R, G, B, Colors = Colors.R, Colors.G, Colors.B, nil
	if UnNil(NoVipColrs) then
		local BestColor, Difference = NoVipColrs[1], math.huge
		for i = 1, #NoVipColrs do
			local colr = NoVipColrs[i]
			local newDiff = math.sqrt((R-colr.R)^2 + (B-colr.B)^2 + (G-colr.G)^2)
			
			if newDiff < Difference then
				Difference = newDiff
				BestColor = colr
			end
		end
		print(BestColor)
		return Color3.new(BestColor.R, BestColor.G, BestColor.B)
	else
		return Color3.new(R, G, B)
	end
end

local function CreateProps(propTable, Obj)
	local props = {}

	if Obj then
		--convert all object proerties into the prop table
		local PointLight = Obj:FindFirstChild("PointLight")
		props = {
			['Reflectance'] = Obj.Reflectance,
			['CanCollide'] = Obj.CanCollide,
			['Color'] =  Color3.fromRGB(Obj.Color.R, Obj.Color.G, Obj.Color.B),
			['LightColor'] = Color3.fromRGB(PointLight.Color.R, PointLight.Color.G, PointLight.Color.B), --default value is wierd
			['Transparency'] = Obj.Transparency,
			['Light'] = Obj.PointLight.Range,
			['Material'] = UnNil(MaterialId, MaterialToNum(Obj.Material)),
			['Shape'] = 1,
			['Size'] = 1
		}
	else
		props = {
			['Reflectance'] = 0,
			['CanCollide'] = true,
			['Color'] =  Color3.new(0, 0, 0),
			['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --default value is wierd
			['Transparency'] = 0,
			['Light'] = 0,
			['Material'] = UnNil(MaterialId, MaterialToNum(Obj.Material)),
			['Shape'] = 1,
			['Size'] = 1
		}
	end

	if typeof(propTable) == 'table' then 
		for i, v in pairs(propTable) do
			props[i] = v
		end
	end

	return props
end

local function MaterialToNum(item) --doesnt take in instances
	if typeof(item) == 'EnumItem' then
		item = tostring(item):split(".")[3]
	elseif typeof(item) == 'number' then
		item = MaterialIds[item]
		return UnNil(item, 'Number out of table max/min: '..#MaterialIds)
	end
	
	return UnNil(item, 1)
end

local function WaitInQueue()
    while getgenv().blockqueue >= getgenv().blocklimit do
        task.wait(0.2)
    end
    getgenv().blockqueue += 1
    return
end

local function QueueOver()
	task.wait(1.05)
	getgenv().blockqueue -= 1
	return
end

local function ConvertPaos(givenPos, ToBlockate)
	givenPos = UnNil(givenPos, Vector3.new(0,0,0))
	if ToBlockate then
		givenPos = givenPos/4+0.5
		givenPos = Vector3.new(math.floor(givenPos.X+0.5),math.floor(givenPos.Y+0.5),math.floor(givenPos.Z+0.5))
	else
		givenPos = givenPos*4
	end
	return givenPos
end

local function FindObjAtPos(Pos, IsBlockate) 
	local obj
	if IsBlockate then
		Pos = ConvertPos(Pos, true)
	end
	for i, v in pairs(Blocks:GetChildren()) do
		if v:IsA("Part") and v.Position == Pos then
			obj = v
		end
	end
	return obj
end

local function TeleTo(Obj, Yoffset)
	offset = UnNil(Yoffset, 0)
	if typeof(Obj) == 'Instance' then
		LP.Character.HumanoidRootPart.CFrame = CFrame.new(Obj.Position) * CFrame.new(0, offset, 0)
	end
end

local BMod = {}

function BMod.UnNil(...) return UnNil(...) end
function BMod.WaitInQueue(...) return WaitInQueue(...) end
function BMod.QueueOver(...) return QueueOver() end
function BMod.ConvertPos(...) return ConvertPos(...) end
function BMod.GetNearestColor(...) return GetNearestColor(...) end
function BMod.FindObjAtPos(...) return FindObjAtPos(...) end
function BMod.MaterialToNum(...) return MaterialToNum(...) end
function BMod.TeleTo(...) return TeleTo(...) end
--the above ar automaticaly done for you if you just use default roblox stuff, its just duplicated here if you need it for whatevr

function BMod.ClearWorld(DisableWarn)
	local function BreakAll()
		game:GetService("ReplicatedStorage").Sockets.World.LoadTemplate:FireServer("Scratch")
	end
	
	if not UnNil(DisableWarn, false) then BreakAll() return end
	local S = Instance.new("ScreenGui", LP.PlayerGui)
	local F = Instance.new("Frame", S)
	local B = Instance.new("TextButton", F)
	B.Size = UDim2.new(1, 0, 1, 0)
	B.TextScaled = true
	B.Text = "Are you sure you want to clear? This includes all blocks and stats. (if yes, click. if not, wait 5 seconds)"
	F.Position = UDim2.new(0.6, 0, 0.2, 0)
	F.Size = UDim2.new(0, 150, 0, 120)

	B.MouseButton1Click:Connect(function()
		BreakAll()
		S:Destroy()
	end)
	
	pcall(function()
		LP.Character.Humanoid.Died:Connect(function()
			S:Destroy()
			return
		end)
	end)
	
	task.wait(5)
	S:Destroy()
	return
end

function BMod.place(x, y, z, propTable) --color properties require the GetNearestColor(R, G, B) function or an actual Color3.new(value) that you own
	WaitInQueue()
	spawn(function()
		local x, y, z = tostring(math.floor(UnNil(x, 0)+0.5)), tostring(math.floor(UnNil(y, 0)+0.5)), tostring(math.floor(UnNil(z, 0)+0.5))
		local pos = x..' '..y..' '..z.."/0" --this number is the orientation (possible values 4, 16, 0, 20) but i cant giv a shid about implemeting it
		local args = {
			[1] = pos,
			[2] = {
				["Reflectance"] = 0,
				["CanCollide"] = true,
				["Color"] = Color3.new(0,0,0),
				["LightColor"] = Color3.new(0,0,0),
				["Transparency"] = 0,
				["Light"] = 0,
				["Material"] = 1,
				["Shape"] = 1,
				["Size"] = 1
			}
		}
		if typeof(propTable) == 'table' then 
			for i, v in pairs(propTable) do
				args[2][i] = v
			end
		end

	    EditRems.Place:InvokeServer(unpack(args))
		QueueOver()
	end)
end

function BMod.delete(InstOrPos)
	WaitInQueue()

	spawn(function()
		if typeof(InstOrPos) == 'Vector3' then InstOrPos = FindObjAtPos(InstOrPos, true) end
		EditRems.Delete:FireServer(InstOrPos)
		QueueOver()
	end)
end

--function BMod.paint(ObjTab, BrushThick, propTable) --very good for mass changes to world, only included color, material, and brush change since others cant change (and dont forget to use GetNearestColor() for color changes)
		
function BMod.paint(ObjTab, color3, MaterialId, BrushThick) --very good for mass changes to world, only included color, material, and brush change since others cant change (and dont forget to use GetNearestColor() for color changes)
		WaitInQueue()
		print"working"
		spawn(function()
			if typeof(ObjTab) == 'table' then
				for i = 1, #ObjTab do
					if typeof(ObjTab[1]) == 'Vector3' then
						ObjTab[i] = FindObjAtPos(Obj, true)
						ObjTab[i] = UnNil(ObjTab[i])
					end
				end
			elseif typeof(ObjTab) == 'Vector3' then
				ObjTab = FindObjAtPos(Obj, true)
				ObjTab = {UnNil(ObjTab)}
			elseif typeof(ObjTab) == 'Instance' then
				ObjTab = {UnNil(ObjTab)}
			else
				warn("no object")
				return
			end
			print(typeof(ObjTab))
			
			local args = {}
			
			local function AddArgs(Obj)
				print(Obj.Name, color3, MaterialId)
				--for som reason it doesnt go past this
				local args2 = {
					[1] = Obj, --add numbers to all for less conufiosn
					[2] = Obj,
					[3] = {
						['Reflectance'] = 1,
						['CanCollide'] = true,
						['Color'] =  color3,
						['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --cant paint a block with light, gotta leave these values for rmote to work
						['Transparency'] = 1,
						['Light'] = 0,
						['Material'] = MaterialId,
						['Shape'] = 1,
						['Size'] = 1
					},
					[4] = UnNil(BrushThick, 1), -- brush thickness
					[5] = {
						['Color'] = true,
						['Material'] = true,
					}    
				}
				args[#args+1] = args2
			end
	
			for i = 1, #ObjTab do
				if UnNil(ObjTab) then
					AddArgs(ObjTab[i])
				end    
			end
			
			args = {args}
			
			for i, v in pairs(args[1]) do 
				print(i,v[3]["Color"])
			end
			print'painting'
			EditRems.Paint:FireServer(unpack(args))
			QueueOver()
		end)
	--temporary solution
	--[[
	WaitInQueue()
	print"working"
	spawn(function()
		if typeof(ObjTab) == 'table' then
			for i = 1, #ObjTab do
				if typeof(ObjTab[1]) == 'Vector3' then
					ObjTab[i] = FindObjAtPos(Obj, true)
					ObjTab[i] = UnNil(ObjTab[i])
				end
			end
		elseif typeof(ObjTab) == 'Vector3' then
			ObjTab = FindObjAtPos(Obj, true)
			ObjTab = {UnNil(ObjTab)}
		elseif typeof(ObjTab) == 'Instance' then
			ObjTab = {UnNil(ObjTab)}
		else
			warn("no object")
			return
		end
		print(typeof(ObjTab))
		
		local args = {}
		
		local function AddArgs(Obj)
			print(Obj.Name)
			local args2 = {
                [1] = Obj, --add numbers to all for less conufiosn
                [2] = Obj,
                [3] = {
                    ['Reflectance'] = 0,
                    ['CanCollide'] = true,
                    ['Color'] =  color3,
                    ['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --cant paint a block with light, gotta leave these values for rmote to work
                    ['Transparency'] = 0,
                    ['Light'] = 0,
                    ['Material'] = UnNil(MaterialId, MaterialToNum(Obj.Material)),
                    ['Shape'] = 1,
                    ['Size'] = 1
                },
                [4] = UnNil(BrushThick, 1), -- brush thickness
                [5] = {
                    ['Color'] = true,
                    ['Material'] = true,
                }
            }
			for i = 1, #args2 do 
				print(args[i])
				args[#args+1] = args2[i]
			end
		end

		for i = 1, #ObjTab do
			if UnNil(ObjTab) then
				AddArgs(ObjTab[i])
			end	
		end
		
		for i, v in pairs(args) do 
			print(i,v)
		end
		print'painting'
		EditRems.Paint:FireServer(unpack(args))
		QueueOver()
	end)
	]]
end

--[[
function BMod.Pixelate() --needs to be an image id
	local Image = require(somemodulelol)

	local brightnessArray = {}
	math.randomseed(tick())
	for i = 1, 100 do
		for j = 1, 100 do
			table.insert(brightnessArray, math.max(0, (math.noise(i/100, j/100) + 0.5) * 255))
		end
	end

	local img = Image.fromMonochrome(100, 100, brightnessArray)
	for i = 1, img.height do
		for j = 1, img.width do
			local index = (i - 1) * img.width + j
			local pixel = img.pixels[index]
			
			local p = Instance.new("Part")
			p.Anchored = true
			p.Size = Vector3.new(1, 1, 1)
			p.CFrame = CFrame.new(i, 10, j)
			p.Color = Color3.fromRGB(pixel, pixel, pixel)
			p.Material = Enum.Material.SmoothPlastic
			p.Parent = workspace
		end
		wait()
	end
end
]]

function BMod.callCommand(commandName, params)
	Rems.Command:InvokeServer('!'..commandName.." "..params)
end

function BMod.GamepassSerivce(itemID, price, func)
	--working on
end

function BMod.MarkPart()
	
end

function BMod:Touched(GivnObj, EventName) --they should make their own as there will be part initializer option
	if typeof(GivnObj) ~= 'Instance' then print('Item must be an instance') return end
	local Event = Instance.new("BindableEvent")
	Event.Name = EventName
	EventName = nil
	local function CreateTouch(obj, Evnt)
		obj.Touched:Connect(function(obj)
			Evnt:Fire(obj)
		end)
	end
	coroutine.wrap(CreateTouch(GivnObj, Event))()
end 

function BMod:SaveWorld(Exclusions)
	for i, v in pairs(workspace) do
		
	end
	
	for i, v in pairs(LP.leaderstats:GetChildren()) do
	
	end
end

function BMod:LoadWorld()
	
end
--ok i swer i stop making functions and start making them work

return BMod
