local HTTPServ = game:GetService("HttpService")
local RepStorage = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local LP = plrs.LocalPlayer
local LPGui = LP:WaitForChild("PlayerGui")

local BuildUi = LPGui:WaitForChild("MainGUI"):WaitForChild("ScreenGui")
local Blocks = workspace:WaitForChild("Blocks")
local Rems = RepStorage.Sockets
local EditRems = Rems.Edit
local NoVipColorIds, MaterialIds, ShapeIds = nil, {}, {}
local SizeIds = { --dont change order
	{4, 4, 4},
	{4, 2, 4},
	{2, 4, 4},
	{4, 4, 2},
	{2, 2, 2},
	{2, 4, 2},
	{4, 2, 2},
	{2, 2, 4}
}

local RotationIds = { --dont change order
	{0, 0, 1},
	{0, 0, 2},
	{0, 0, 3},
	
	{2, 0, 2},
	{2, 0, 3},
	{2, 0, 0},
	{2, 0, 1},

	{1, 0, 3},
	{1, 0, 0},	
	{1, 0, 1},
	{1, 0, 2},

	{3, 0, 3},
	{3, 0, 0},
	{3, 0, 1},
	{3, 0, 2},
		
	{0, 3, 0},
	{3, 3, 0},
	{2, 3, 0},	
	{1, 3, 0},

	{0, 1, 0},
	{1, 1, 0},	
	{2, 1, 0},
	{3, 1, 0}
}

repeat task.wait(0.3) until LPGui.Loading.Enabled == false

getgenv().getRank = function()
	return LPGui:WaitForChild("WorldMenuGui"):WaitForChild("WorldMenu"):WaitForChild("TabsFrame"):WaitForChild("Players"):WaitForChild(LP.UserId):WaitForChild("PermFrame"):WaitForChild("PermName").Text
end

if not game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LP.UserId, 3756285) then 
	getgenv().IsVip = false -- all getgenvs is for your uses if you wanted to include something
	local colrFoldr = nil
	NoVipColorIds = {}
	for i, v in pairs(BuildUi:GetChildren()) do
		if v.Name == 'Color' and v:FindFirstChild("Content") and v.Content:FindFirstChild("Palette") then
			colrFoldr = v.Content.Palette:WaitForChild("Content")
		end
	end
	
	for i, v in pairs(colrFoldr:GetChildren()) do
		if v:IsA('ImageButton') then
			table.insert(NoVipColorIds, v.BackgroundColor.Color)
		end
	end
else
	getgenv().IsVip = true
end

do --get properties' info
	local function sortUI(Folder, Class)
		local Tab = {}
		for i, v in pairs(Folder:GetChildren()) do
			if v:IsA(Class or "TextButton") then
				Tab[#Tab + 1] = v.Text --there might be a better way to do this through script RepStorage.Modules.Client.Building, same for color
			end
		end
		return Tab
	end

	local matFolder
	local function getFolders()
		print'begin'
		local KWs = {"Plastic", "Block"}
		local all = {} --folder
		for i, v in pairs(BuildUi:GetChildren()) do
			if #all ~= 3 and v.Name == "Dropdown" then
				local Button = v.Dropdown.Content:FindFirstChildOfClass("TextButton")
				local Index = table.find(KWs, Button.Text)
				if Index then
					all[Index] = Button.Parent
				end
			end
		end
		return all
	end
	local Folders = getFolders()
	--[[for _, v in pairs(Folders) do for _, v2 in pairs(v:GetChildren()) do if v2:IsA("TextButton") then print(v2.Text) end end end --Test Tables]]
	matFolder, shapeFolder = Folders[1], Folders[2]
	MaterialIds = sortUI(matFolder)
	ShapeIds = sortUI(shapeFolder)
end

local function UnNil(Value, Default) --uhhh
	if Value ~= nil and typeof(Value) ~= 'nil' then
		return Value
	end
	return Default or false
end

local function FindVector(IDTable, Vector) --honestly this is useless
	for i = 1, #IDTable do
		local Val = IDTable[i]
		if Vector.X == Val[1] and Vector.Y == Val[2] and Vector.Z == Val[3] then return i end
	end
	return nil
end

local function MaterialToNum(item, returnEnum)
	if typeof(item) == "Instance" then
		item = item.Material
	end
	if typeof(item) == 'EnumItem' then
		item = table.find(MaterialIds, tostring(item):split(".")[3])
	elseif typeof(item) == 'number' then
        if returnEnum then
		    item = Enum.MaterialIds[item]
        else
            item = MaterialIds[item]
        end
		item = UnNil(item, 'Number out of table max/min: '..#MaterialIds)
	end

	return UnNil(item, 1)
end

local function ShapeToNum(item)
	if typeof(item) == "Instance" then 
		item = item.Name
	end
    return table.find(ShapeIds, item)
end

local function SizeToNum(item)
	if typeof(item) == "Instance" then
		item = item.Size
	end
	return FindVector(SizeIds, item)
end

local function GetLightRangeAndColor(item)
	local PointLight, range, color = item:FindFirstChild("PointLight"), 0, Color3.new(0.94902,0.952941,0.952941)
	if not PointLight then return range, color end
	range, color = PointLight.Range, Color3.fromRGB(PointLight.Color.R, PointLight.Color.G, PointLight.Color.B)
	return range, color
end

local function FindObjAtPos(Pos) 
	local obj
	for i, v in pairs(Blocks:GetChildren()) do
		if v:IsA("Part") and v.Position == Pos then
			obj = v
		end
	end
	return obj
end

local function TeleTo(ObjPos, Vec3Offset) --[Obj] can be a part or Vector3, [Vec3Offset] can be Vector3 OR Y offset
	if typeof(Vec3Offset) == 'number' then Vec3Offset = Vector3.new(0, Vec3Offset, 0) end
	
	if typeof(ObjPos) == 'Instance' then
		ObjPos = Obj.Position
	end
	
	LP.Character.PrimaryPart.CFrame = CFrame.new(ObjPos.X+Vec3Offset+X, ObjPos.Y+Vec3Offset.Y, ObjPos.Z+Vec3Offset.Z)
end

local function CFToPosStr(givenCF, ToRoblox, AddSigns)--if its a blockate position (they use strings), set ToRoblox to true to extract a roblox CFrame from it
	local givenOrient, output --output will be returned(CFrame if ToRoblox, String if not)
	if typeof(givenCF) == "Instance" then
		givenOrient = givenCF.Orientation
		givenCF = givenCF.CFrame
	elseif typeof(givenCF) == "Vector3" then
		--givenCF = CFrame.new(givenCF)
		givenOrient = Vector3.new(0,0,0)
	end

	if not ToRoblox then --makes a CFrame(or vector3) into a string to use in the BMod.place() function
		local posTab = {}
		givenPos = {givenCF.X/4, givenCF.Y/4, givenCF.Z/4}

		for i, v in pairs(givenPos) do
			local num, sign = math.floor(v+0.5), '-'
			if num < v then
				sign = '+'
			end
			posTab[i] = tostring(num)..sign
		end
		posTab[1], posTab[2] = posTab[1]..' ', posTab[2]..' '

		if not givenOrient then
			local x,y,z = givenCF:ToOrientation()
			givenOrient = Vector3.new(math.deg(x),math.deg(y),math.deg(z))
		end
		local function toRightAngle(degr)
			local angle = math.floor((degr+360)%360/90+0.5)
			if angle == 4 then angle = 0 end
			return angle
		end

		givenOrient = Vector3.new(toRightAngle(givenOrient.X), toRightAngle(givenOrient.Y), toRightAngle(givenOrient.Z))
		local id = UnNil(FindVector(RotationIds, givenOrient), 0)
		print(givenOrient, id)

		posTab[3] = posTab[3]..'/'..tostring(id)
		output, posTab = table.concat(posTab), nil
	else --this turns output into a real Vector3
		local posTab = givenCF:split(' ')
		local data = posTab[3]:split('/')
		posTab[3], posTab[4], data = data[1], data[2], nil

		for i = 1, 3 do
			N = posTab[i]
			local add = 0

			if string.find(N, '-') then
				add = -2
			elseif string.find(N, '+') then
				add = 2
			end
			posTab[i] = N*4 + add
		end
		local rot = RotationIds[posTab[4]]
		posTab[4], rot = nil, Vector3.new(rot.X*90, rot.Y*90, rot.Z*90)
		
		output = CFrame.new(posTab[1], posTab[2], posTab[3]) * CFrame.Angles(math.rad(rot.X), math.rad(rot.Y), math.rad(rot.Z))
	end
	return output
end

local function safePosString(String, Size)
	if not Size then print'no size' Size = Vector3.new(4,4,4) end
	local segments, Size = String:split(" "), {Size.X, Size.Y, Size.Z}
	local Z = segments[3]:split('/') --break the 3rd arg into 2 things
	segments[3] = Z[1]
	if tonumber(Z[2]) < 0 then Z[2] = '0' print('wrong orient') end --sets orientation to 0 if negative
	
	for i = 1, #segments do
		seg = segments[i]
		if Size[i] == 4 then --erase if the size cant use + or -
			print(Size[i], "is 4")
			if string.find(seg, '[%+%-]', 2) then
				segments[i] = string.sub(seg, 1, seg:len()-1)
			end
		else
			print(segments[i], "has a size of", Size[i])
		end
	end
	segments[3] = segments[3]..'/'..Z[2] --reapply orientation
	return table.concat(segments, ' ')
end

local function GetNearestColor(R, G, B) --input a color3 
	if typeof(R) == 'Instance' then
		R = R.Color
	end

	if typeof(R) == 'Color3' then
		B = R.B
		G = R.G
		R = R.R
	elseif typeof(R) == 'table' then
		B = R[2]
		G = R[3]
		R = R[1]
	end

	--R, G, B = R*255, G*255, B*255
	if not getgenv().IsVip then
		local BestColor, Difference = NoVipColorIds[20], math.huge
		for i = 1, #NoVipColorIds do
			local colr = NoVipColorIds[i]
			local newDiff = math.sqrt((R-colr.R)^2 + (B-colr.B)^2 + (G-colr.G)^2)
			
			if newDiff < Difference then
				Difference = newDiff
				BestColor = colr
			end
		end
		return Color3.new(BestColor.R, BestColor.G, BestColor.B)
	else
		return Color3.new(R, G, B)
	end
end

local function CreateProps(propTable, Obj, approximateColors) --creates a template for properties of a basic obj. obj parameter is for copying obj props
	local props = {
		['Reflectance'] = 0,
		['CanCollide'] = true,
		['Color'] =  Color3.new(0, 0, 0),
		['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --default value is wierd
		['Transparency'] = 0,
		['Light'] = 0,
		['Material'] = 1,
		['Shape'] = 1,
		['Size'] = 1
	}

	if Obj then --obj is optional, this just clones the object
		--convert all object proerties and overwrit the prop table as a new default
		local range, color = GetLightRangeAndColor(Obj)
		props = {
			['Reflectance'] = Obj.Reflectance or props['Reflectance'],
			['CanCollide'] = Obj.CanCollide or props['CanCollide'],
			['Color'] = Obj.Color or props['Color'],
			['LightColor'] = color or props['LightColor'],
			['Transparency'] = Obj.Transparency or props['Transparency'],
			['Light'] = range or props['Light'],
			['Material'] = MaterialToNum(Obj.Material) or props['Material'],
			['Shape'] = ShapeToNum(Obj) or props['Shape'],
			['Size'] = SizeToNum(Obj) or props['Size']
		}
		print('lights:', range, color)
		print('size:', props['Size'])
	end
	--change values to proptable
	if propTable then 
		for i, v in pairs(propTable) do
			props[i] = v
		end
	end

	if approximateColors then
		props['Color'] = GetNearestColor(props['Color'])
		props['LightColor'] = GetNearestColor(props['LightColor'])
	end
	return props
end

getgenv().blocklimit = 43 --donot set this over 50(might get kicked), but yu are free to chang it to wuteva
getgenv().blockqueue = 0

local function WaitInQueue()
	if getgenv().blockqueue >= getgenv().blocklimit then
		task.wait(0.5)
	end
    while getgenv().blockqueue >= getgenv().blocklimit do
        task.wait(0.2)
    end
    getgenv().blockqueue += 1
    return
end

local function QueueOver()
	task.wait(1.05)
	getgenv().blockqueue -= 1
	return
end


local BMod = {}

getgenv().NoVipColorIds = NoVipColorIds
getgenv().MaterialIds = MaterialIds
getgenv().ShapeIds = ShapeIds
getgenv().SizeIds = SizeIds

function BMod.UnNil(...) return UnNil(...) end
function BMod.MaterialToNum(...) return MaterialToNum(...) end
function BMod.ShapeToNum(...) return ShapeToNum(...) end
function BMod.SizeToNum(...) return SizeToNum(...) end
function BMod.GetLightRangeAndColor(...) return GetLightRangeAndColor(...) end
function BMod.FindObjAtPos(...) return FindObjAtPos(...) end
function BMod.TeleTo(...) return TeleTo(...) end
function BMod.CFToPosStr(...) return CFToPosStr(...) end
function BMod.safePosString(...) return safePosString(...) end
function BMod.GetNearestColor(...) return GetNearestColor(...) end
function BMod.CreateProps(...) return CreateProps(...) end
function BMod.WaitInQueue(...) return WaitInQueue(...) end
function BMod.QueueOver(...) return QueueOver() end
function BMod.Notify(...) return game.StarterGui:SetCore("SendNotification", ...) end --its jus roblox's notification i lik it so i simplified it
--this stuf is put into the module if yu want to use it (idk why u would need them)

function BMod.place(PosString, propTable) --color properties require the GetNearestColor(R, G, B) function or an actual Color3.new(value) that you own. Also, PosString is in terms of blockate's placement system (use CFToPosStr WITH safePosString OR simply use a CFrame)
	local old = PosString
	if typeof(PosString) ~= 'string' then
		PosString = CFToPosStr(PosString, false)
	end
	
	if propTable and propTable['Size'] then
		local size = SizeIds[propTable['Size']]
		size = Vector3.new(size[1], size[2], size[3])
		PosString = safePosString(PosString, size)
	else 
		PosString = safePosString(PosString)
	end
	
	propTable = CreateProps(propTable, _, true)

	WaitInQueue()
	coroutine.wrap(function()
		print("oldData \n", old, PosString, propTable[Size])
	    EditRems.Place:InvokeServer(
			PosString, 
			propTable
		)
		QueueOver()
		return
	end)()
end

function BMod.delete(InstOrPos) --provide either instance or position
	WaitInQueue()

	coroutine.wrap(function()
		if typeof(InstOrPos) == 'Vector3' then InstOrPos = FindObjAtPos(InstOrPos, true) end
		EditRems.Delete:FireServer(InstOrPos)
		QueueOver()
		return
	end)()
end

function BMod.paint(ObjTab, propTable, BrushThick) --very good for mass changes to world, ONLY color, material, and brush thickness can change
	WaitInQueue()
	coroutine.wrap(function()
		if typeof(ObjTab) == 'table' then
			for i = 1, #ObjTab do
				if typeof(ObjTab[1]) == 'Vector3' then
					ObjTab[i] = FindObjAtPos(Obj, true)
					ObjTab[i] = UnNil(ObjTab[i])
				end
			end
		elseif typeof(ObjTab) == 'Vector3' then
			ObjTab = FindObjAtPos(Obj, true)
			ObjTab = {UnNil(ObjTab)}
		elseif typeof(ObjTab) == 'Instance' then
			ObjTab = {UnNil(ObjTab)}
		else
			warn("no object")
			return
		end
		
		local args = {}
		local propTable = CreateProps(propTable)
		local function AddArgs(Obj)
			--for som reason it doesnt go past this
			local args2 = {
				[1] = Obj, --add numbers to all for less conufiosn
				[2] = Obj,
				[3] = propTable,
				[4] = UnNil(BrushThick, 1), -- brush thickness
				[5] = {
					['Color'] = true,
					['Material'] = true,
				}    
			}
			--CreateProps() can make it smaller
			args[#args+1] = args2
		end

		for i = 1, #ObjTab do
			if UnNil(ObjTab) then
				AddArgs(ObjTab[i])
			end    
		end
		
		args = {args}
		
		EditRems.Paint:FireServer(unpack(args))
		QueueOver()
		return
	end)()
end

function BMod.ClearWorld(deleteStarterblock, DisableWarn)
	local function BreakAll()
		if getgenv().getRank() == "Owner" then
			game:GetService("ReplicatedStorage").Sockets.World.LoadTemplate:FireServer("Scratch")
		else
			for _, obj in pairs(Blocks:GetChildren()) do
				BMod.delete(obj)
			end
		end
		if deleteStarterblock then
			Blocks:WaitForChild("Block", 1)
			if Blocks:FindFirstChild("Block") then
				BMod.delete(Blocks.Block)
			end			
		else
			BMod.place("0 0 0/0", {['Color'] = Color3.new(242, 243, 243)})
		end
	end
	if DisableWarn then BreakAll() return end
	local bind = Instance.new("BindableFunction")
	function bind.OnInvoke()
		BreakAll()
		bind:Destroy()
	end
	BMod.Notify({
		Title = "Clear the world?",
		Text = "This includes all blocks and stats (wait 5 sec if you dont want to clear)",
		Button1 = "Confirm clearing world",
		Callback = bind,
		Duration = 5
	})
	task.wait(5)
	bind:Destroy()
	return
end

--[[ uhh dont worry about this

function BMod.Pixelate() --needs to be an image id
	local Image = require(somemodulelol)

	local brightnessArray = {}
	math.randomseed(tick())
	for i = 1, 100 do
		for j = 1, 100 do
			table.insert(brightnessArray, math.max(0, (math.noise(i/100, j/100) + 0.5) * 255))
		end
	end

	local img = Image.fromMonochrome(100, 100, brightnessArray)
	for i = 1, img.height do
		for j = 1, img.width do
			local index = (i - 1) * img.width + j
			local pixel = img.pixels[index]
			
			local p = Instance.new("Part")
			p.Anchored = true
			p.Size = Vector3.new(1, 1, 1)
			p.CFrame = CFrame.new(i, 10, j)
			p.Color = Color3.fromRGB(pixel, pixel, pixel)
			p.Material = Enum.Material.SmoothPlastic
			p.Parent = workspace
		end
		wait()
	end
end
]]

function BMod.callCommand(commandName, params)
	Rems.Command:InvokeServer('!'..commandName.." "..params)
end

function BMod.GamepassSerivce(itemID, bluxPrice, func)
	--working on later
end

function BMod.MarkPart() --u can use Part.Touched on the uniquely marked part
	--working on later
end

function BMod.SaveWorld(filename, exclusions) --only saves block type, placement, and texture
	print'Saving world..'
	BMod.Notify({Title = "Saving world..", Text = "Do not leave", Duration = 2})
	if not filename then
		local Defaultname = "BlockateSave"
		local i = 0
		repeat
			filename = readfile(Defaultname..i)
		until not filename
		filename = Defaultname..i..".txt"
	end
	local function PackColor(color3)
		return {color3.R, color3.G, color3.B}
	end

    local file = {['Blocks'] = {}}
	for i, part in pairs(Blocks:GetChildren()) do
		local posStr, props = CFToPosStr(part), CreateProps(_, part)
		props.Color = PackColor(props.Color)
		props.LightColor = PackColor(props.LightColor)
		file.Blocks[#file.Blocks+1] = {posStr, props} --turn the color3 vals into a number table bc they cant store in json
	end

    writefile(filename..'.json', HTTPServ:JSONEncode(file))
	print'Save complete!'
	BMod.Notify({Title = "Save complete!", Text = "", Duration = 0.7})
end

function BMod.LoadWorld(filename, exclusions)
	print'Loading..'
	BMod.Notify({Title = "Loading save..", Text = "", Duration = 2})
    local file = HTTPServ:JSONDecode(readfile(filename..'.json'))
    if not filename or not file then warn("Provide a filename (file may be corrupted)") return end
    filename = nil
	local function UnpackColor(tab)
		return Color3.new(tab[1], tab[2], tab[3])
	end

    for _, data in pairs(file.Blocks) do
    	local block = data[2]
    	block.Color = UnpackColor(block.Color)
    	block.LightColor = UnpackColor(block.LightColor)
    	table.foreach(block, print)

        BMod.place(data[1], block)
    end
	print'Loading complete!'
	BMod.Notify({Title = "Loading complete!", Text = "", Duration = 0.7})
	return
end
print'successfully returned'
return BMod
--[[
Contributors
wrty (no github brueh)
araknala

]]
