
--initializing genvs

getgenv().debugOut = getgenv().debugOut or function() return end --set to print/warn or your own callback for output that will handle multiple args and tostring them, else set it to function() return end
getgenv().blocklimit = getgenv().blocklimit or 43--donot set this over ~45 (might get kicked), but yu are still free to chang it

--These getgenvs shod be treated like readonly. dont modify them cause it can create errors (unless yk why u are doing it)

getgenv().blockqueue = 0
getgenv().IsVip = nil
getgenv().getRank = nil
getgenv().noVipColorIds = nil
getgenv().materialIds = nil
getgenv().shapeIds = nil
getgenv().sizeIds = nil

local HTTPServ = game:GetService("HttpService")
local RepStorage = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local LP = plrs.LocalPlayer
local LPGui = LP:WaitForChild("PlayerGui")

local BuildUi = LPGui:WaitForChild("MainGUI"):WaitForChild("ScreenGui")
local Blocks = workspace:WaitForChild("Blocks")
local Rems = RepStorage.Sockets
local EditRems = Rems.Edit
local noVipColorIds, materialIds, shapeIds = nil, {}, {}
local sizeIds = { --dont change order
	{4, 4, 4},
	{4, 2, 4},
	{2, 4, 4},
	{4, 4, 2},
	{2, 2, 2},
	{2, 4, 2},
	{4, 2, 2},
	{2, 2, 4}
}

local RotationIds = { --dont change order 4-8, 10-12, 14-15, 18, 23
	{0, 0, 1},
	{0, 0, 2},
	{0, 0, 3}, --3
	
	{0, 2, 0},
	{0, 2, 1},
	{0, 2, 2},
	{0, 2, 3}, --7

	{1, 1, 0},
	{1, 0, 0},	
	{1, 3, 0},
	{1, 2, 0}, --11

	{3, 3, 0},
	{3, 0, 0},
	{3, 1, 0},
	{3, 2, 0}, --15
		
	{0, 3, 0},
	{0, 3, 1},
	{0, 3, 2},	
	{0, 3, 3}, --19

	{0, 1, 0},
	{0, 1, 1},	
	{0, 1, 2},
	{0, 1, 3} --23
}

repeat task.wait(0.3) until LPGui.Loading.Enabled == false

getgenv().getRank = function()
	return LPGui:WaitForChild("WorldMenuGui"):WaitForChild("WorldMenu"):WaitForChild("TabsFrame"):WaitForChild("Players"):WaitForChild(LP.UserId):WaitForChild("PermFrame"):WaitForChild("PermName").Text
end

if not game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LP.UserId, 3756285) then 
	getgenv().IsVip = false -- all getgenvs is for your uses if you wanted to include something
	local colrFoldr = nil
	noVipColorIds = {}
	for i, v in pairs(BuildUi:GetChildren()) do
		if v.Name == 'Color' and v:FindFirstChild("Content") and v.Content:FindFirstChild("Palette") then
			colrFoldr = v.Content.Palette:WaitForChild("Content")
		end
	end
	
	for i, v in pairs(colrFoldr:GetChildren()) do
		if v:IsA('ImageButton') then
			table.insert(noVipColorIds, v.BackgroundColor.Color)
		end
	end
else
	getgenv().IsVip = true
end

do --get properties' info
	local function sortUI(Folder, Class)
		local Tab = {}
		for i, v in pairs(Folder:GetChildren()) do
			if v:IsA(Class or "TextButton") then
				Tab[#Tab + 1] = v.Text --there might be a better way to do this through script RepStorage.Modules.Client.Building, same for color
			end
		end
		return Tab
	end

	local matFolder
	local function getFolders()
		getgenv().debugOut('Getting material folders')
		local KWs = {"Plastic", "Block"}
		local all = {} --folder
		for i, v in pairs(BuildUi:GetChildren()) do
			if #all ~= 3 and v.Name == "Dropdown" then
				local Button = v.Dropdown.Content:FindFirstChildOfClass("TextButton")
				local Index = table.find(KWs, Button.Text)
				if Index then
					all[Index] = Button.Parent
				end
			end
		end
		return all
	end
	local Folders = getFolders()
	--[[for _, v in pairs(Folders) do for _, v2 in pairs(v:GetChildren()) do if v2:IsA("TextButton") then print(v2.Text) end end end --Test Tables]]
	matFolder, shapeFolder = Folders[1], Folders[2]
	materialIds = sortUI(matFolder)
	shapeIds = sortUI(shapeFolder)
    getgenv().debugOut("Successfully got material folders")
end

local function unNil(Value, Default) --uhhh
	if Value ~= nil and typeof(Value) ~= 'nil' then
		return Value
	end
	return Default or false
end

local function viewPart(Part, Whiteness) --for debug purposes
	local BHD = Instance.new("BoxHandleAdornment")
	BHD.Color = BrickColor.new(Color3.fromRGB(Whiteness, Whiteness, Whiteness))
	BHD.ZIndex = 0
	BHD.AlwaysOnTop = true
	BHD.Transparency = 0.6
	BHD.Size = Part.Size
	BHD.Adornee = Part
	BHD.Parent = Part
	return BHD
end

local function FindVector(IDTable, Vector) --honestly this is useless
	for i = 1, #IDTable do
		local Val = IDTable[i]
		if Vector.X == Val[1] and Vector.Y == Val[2] and Vector.Z == Val[3] then return i end
	end
	return nil
end

local function materialToNum(item, returnEnum)
	if typeof(item) == "Instance" then
		item = item.Material
	end
	if typeof(item) == 'EnumItem' then
		item = table.find(materialIds, tostring(item):split(".")[3])
	elseif typeof(item) == 'number' then
        if returnEnum then
		    item = Enum.materialIds[item]
        else
            item = materialIds[item]
        end
		item = unNil(item, 'Number out of table max/min: '..#materialIds)
	end

	return unNil(item, 1)
end

local function shapeToNum(item)
	if typeof(item) == "Instance" then 
		item = item.Name
	end
    return table.find(shapeIds, item)
end

local function sizeToNum(item)
	if typeof(item) == "Instance" then
		item = item.Size
	end
	return FindVector(sizeIds, item)
end

local function getLightRangeAndColor(item)
	local PointLight, range, color = item:FindFirstChild("PointLight"), 0, Color3.new(0.94902,0.952941,0.952941)
	if not PointLight then return range, color end
	range, color = PointLight.Range, Color3.fromRGB(PointLight.Color.R, PointLight.Color.G, PointLight.Color.B)
	return range, color
end

local function findObjAtPos(Pos, AllowNearest) 
	local obj
	local nearDist = math.huge
	for i, v in pairs(Blocks:GetChildren()) do
		if v:IsA("Part") then
			local vPos = v.Position

			if AllowNearest then
				local dist = (vPos-Pos).Magnitude
				
				if dist == nearDist then
					return v
				elseif dist <= nearDist then
					obj = v
					nearDist = dist
				end

			elseif vPos == Pos then
				return v
			end
		end
	end
	return obj
end

local function teleTo(ObjPos, Vec3Offset) --[Obj] can be a part or Vector3, [Vec3Offset] can be Vector3 OR Y offset
	local charPart = LP.Character:FindFirstChild("HumanoidRootPart") or LP.Character:FindFirstChild("Head") or LP.Character:FindFirstChildOfClass("Part")
    if not charPart then Msg = 'No part found in your character' getgenv().debugOut(Msg) return Msg end
    local human = Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') 
    if human and human.SeatPart then
        human.Sit = false
        task.wait(.1)
    end
    
    Vec3Offset = Vec3Offset or Vector3.new()
    if typeof(Vec3Offset) == 'number' then Vec3Offset = Vector3.new(0, Vec3Offset, 0) end
	if typeof(ObjPos) == 'Instance' then
		ObjPos = ObjPos.Position
	end
    local Pos = ObjPos.X+Vec3Offset.X, ObjPos.Y+Vec3Offset.Y, ObjPos.Z+Vec3Offset.Z
	charPart.CFrame = CFrame.new(Pos)
    getgenv().debugOut(charPart.Name.." successfully teleported to position "..tostring(Pos))
end

local function CFToCFStr(givenCF, ToRoblox, AddSigns)--if its a blockate position (they use strings), set ToRoblox to true to extract a roblox CFrame from it
	local givenOrient, output --output will be returned(CFrame if ToRoblox, String if not)
	
	if typeof(givenCF) == "Vector3" then
		--givenCF = CFrame.new(givenCF)
		givenOrient = Vector3.new(0,0,0)
	end

	if not ToRoblox then --makes a CFrame(or vector3) into a string to use in the BMod.place() function
		local posTab = {}
		givenPos = {givenCF.X/4, givenCF.Y/4, givenCF.Z/4}

		for i, v in pairs(givenPos) do
			local num, sign = math.floor(v+0.5), '-'
			if num < v then
				sign = '+'
			end
			posTab[i] = tostring(num)..sign
		end
		posTab[1], posTab[2] = posTab[1]..' ', posTab[2]..' '

		if not givenOrient then
			local x,y,z = givenCF:ToOrientation()
			givenOrient = Vector3.new(math.deg(x),math.deg(y),math.deg(z))
		end
		local function toRightAngle(degr)
			local angle = math.floor((degr+360)%360/90+0.5)
			if angle == 4 then angle = 0 end
			return angle
		end

		givenOrient = Vector3.new(toRightAngle(givenOrient.X), toRightAngle(givenOrient.Y), toRightAngle(givenOrient.Z))
		local id = unNil(FindVector(RotationIds, givenOrient), 0)
		posTab[3] = posTab[3]..'/'..tostring(id)
		output, posTab = table.concat(posTab), nil
	else --this turns input into a real Vector3
		local posTab = givenCF:split(' ')
		local data = posTab[3]:split('/')
		posTab[3], posTab[4], data = data[1], data[2], nil

		for i = 1, 3 do
			local N = posTab[i]
			local prefix = string.match(string.reverse(N), "[%+%-]", string.len(N)-1)
			local add = 0
			if prefix then
				if prefix == '-' then
					add = -2
				elseif prefix == '+' then
					add = 2
				end
				N = string.sub(N, 1, string.len(N)-1)
			end
			N = tonumber(N)
			posTab[i] = N*4 + add
		end
		
		local rot = RotationIds[tonumber(posTab[4])]
		posTab[4], rot = nil, Vector3.new(rot[1]*90, rot[2]*90, rot[3]*90)
		
		output = CFrame.new(posTab[1], posTab[2], posTab[3]) * CFrame.Angles(math.rad(rot.X), math.rad(rot.Y), math.rad(rot.Z))
	end
	return output
end

local function safeCFStr(String, Size)
	if not Size then getgenv().debugOut('no size') Size = Vector3.new(4,4,4) end
	local segments, Size = String:split(" "), {Size.X, Size.Y, Size.Z}
	local Z = segments[3]:split('/') --break the 3rd arg into 2 things
	
	segments[3] = Z[1]
	local orient, Z = Z[2], nil
	local orientNum = tonumber(orient)
	
	if orientNum < 0 then orient = '0' elseif orientNum > 23 then orient = '23' end --unsus the orientation
	local orientVal, orientNum = RotationIds[orientNum] or {0,0,0}, nil
	
	for i = 1, 3 do
		local seg = segments[i]
		local Sign = string.find(seg, '[%+%-]', 2)
		local eraseSign = false --uhh implement this, plus it can affect otehr segments' signs sooo fuuucccm,llkkk
		
		if orientVal[i]%2 ~= 0 then
			eraseSign = not eraseSign
		end --uhmm so odd numbers will offset the size
		
		if Sign then --if a +/- is found then clear it & sub it
			local ln, signPos = seg:len(), Sign
			Sign = string.sub(seg, Sign, Sign)
			seg = string.sub(seg, 1, signPos-1)
		else
			Sign = "+"
		end
		
		if Size[i] ~= 4 then
			getgenv().debugOut(Size[i].."isnt 4, it has pos val:", seg, ".giving a "..Sign.." to "..seg)
			seg = seg..Sign --provide sign back if it is 
		end
		
		segments[i] = seg
	end
	segments[3] = segments[3]..'/'..orient --reapply orientation
	return table.concat(segments, ' ')
end

local function getNearestColor(R, G, B) --input a color3 
	if typeof(R) == 'Instance' then
		R = R.Color
	end

	if typeof(R) == 'Color3' then
		B = R.B
		G = R.G
		R = R.R
	elseif typeof(R) == 'table' then
		B = R[2]
		G = R[3]
		R = R[1]
	end

	--R, G, B = R*255, G*255, B*255
	if not getgenv().IsVip then
		local BestColor, Difference = noVipColorIds[20], math.huge
		for i = 1, #noVipColorIds do
			local colr = noVipColorIds[i]
			local newDiff = math.sqrt((R-colr.R)^2 + (B-colr.B)^2 + (G-colr.G)^2)
			
			if newDiff < Difference then
				Difference = newDiff
				BestColor = colr
			end
		end
		return Color3.new(BestColor.R, BestColor.G, BestColor.B)
	else
		return Color3.new(R, G, B)
	end
end

local function createProps(propTable, Obj) --creates a template for properties of a basic obj. obj parameter is for copying obj props
	local props = {
		['Reflectance'] = 0,
		['CanCollide'] = true,
		['Color'] =  Color3.new(0, 0, 0),
		['LightColor'] = Color3.new(0.94902,0.952941,0.952941), --default value is wierd
		['Transparency'] = 0,
		['Light'] = 0,
		['Material'] = 1,
		['Shape'] = 1,
		['Size'] = 1
	}

	if Obj then --obj is optional, this just clones the object
		--convert all object proerties and overwrit the prop table as a new default
		local range, color = getLightRangeAndColor(Obj)
		props = {
			['Reflectance'] = Obj.Reflectance or props['Reflectance'],
			['CanCollide'] = Obj.CanCollide or props['CanCollide'],
			['Color'] = Obj.Color or props['Color'],
			['LightColor'] = color or props['LightColor'],
			['Transparency'] = Obj.Transparency or props['Transparency'],
			['Light'] = range or props['Light'],
			['Material'] = materialToNum(Obj.Material) or props['Material'],
			['Shape'] = shapeToNum(Obj) or props['Shape'],
			['Size'] = sizeToNum(Obj) or props['Size']
		}
	end
	--change values to proptable
	if propTable then 
		for i, v in pairs(propTable) do
			props[i] = v
		end
	end

	if not getgenv().IsVip then
		props['Color'] = getNearestColor(props['Color'])
		props['LightColor'] = getNearestColor(props['LightColor'])
	end
	return props
end

getgenv().blocklimit = 43 --donot set this over 50(might get kicked), but yu are free to chang it to wuteva
getgenv().blockqueue = 0

local function waitInQueue()
	if getgenv().blockqueue >= getgenv().blocklimit then
		task.wait(0.5)
	end
    while getgenv().blockqueue >= getgenv().blocklimit do
        task.wait(0.2)
    end
    getgenv().blockqueue += 1
    return
end

local function queueOver()
	task.wait(1.05)
	getgenv().blockqueue -= 1
	return
end


local BMod = {}

getgenv().noVipColorIds = noVipColorIds
getgenv().materialIds = materialIds
getgenv().shapeIds = shapeIds
getgenv().sizeIds = sizeIds

BMod.unNil = unNil
BMod.viewPart = viewPart
BMod.materialToNum = materialToNum
BMod.shapeToNum = shapeToNum
BMod.sizeToNum = sizeToNum
BMod.getLightRangeAndColor = getLightRangeAndColor
BMod.findObjAtPos = findObjAtPos
BMod.teleTo = teleTo
BMod.CFToCFStr = CFToCFStr
BMod.safeCFStr = safeCFStr
BMod.getNearestColor = getNearestColor
BMod.createProps = createProps
BMod.waitInQueue = waitInQueue
BMod.queueOver = queueOver
BMod.notify = function(...) return game.StarterGui:SetCore("SendNotification", ...) end --its jus roblox's notification i lik it so i simplified it
--this stuf is put into the module if yu want to use it (idk why u would need them)

function BMod.place(PosString, propTable) --Color properties use Color3s and the rest generally r numbers (see the _ToNum functions). Also, PosString is in terms of blockate's placement system (give a CFrame, Vector3, or string)
	local old = PosString
	if typeof(PosString) ~= 'string' then
		PosString = CFToCFStr(PosString, false)
	end
	
	--propTable['Size'] = 1
	if propTable and propTable['Size'] then
		local size = sizeIds[propTable['Size']]
		size = Vector3.new(size[1], size[2], size[3])
		PosString = safeCFStr(PosString, size)
	else
		PosString = safeCFStr(PosString)
	end
	
	propTable = createProps(propTable)

	waitInQueue()
	coroutine.wrap(function()
		getgenv().debugOut("Placing part with data:\n\t", old, PosString, propTable['Size'])
		EditRems.Place:InvokeServer(
			PosString, 
			propTable
		)
		queueOver()
		return
	end)()
end

function BMod.delete(InstOrPos) --provide either instance or position
	waitInQueue()

	coroutine.wrap(function()
		if typeof(InstOrPos) == 'Vector3' then InstOrPos = findObjAtPos(InstOrPos, true) end
		EditRems.Delete:FireServer(InstOrPos)
		queueOver()
		return
	end)()
end

function BMod.paint(ObjTab, propTable, brushThick) --very good for mass changes to world, ONLY color, material, and brush thickness can change
	unNil(brushThick, 1)
	waitInQueue()
	coroutine.wrap(function()
		if typeof(ObjTab) == 'table' then
			--make sure the table only contains objects...
		elseif typeof(ObjTab) == 'Vector3' then
			ObjTab = findObjAtPos(Obj, true)
			ObjTab = {unNil(ObjTab)}
		elseif typeof(ObjTab) == 'Instance' then
			ObjTab = {unNil(ObjTab)}
		else
			warn("no object")
			return
		end
		local args = {}
		local function AddArgs(Obj)
			local propTable = createProps(propTable, obj)
			--for som reason it doesnt go past this, testing
			local args2 = {
				[1] = Obj, --add numbers to all for less conufiosn
				[2] = Obj,
				[3] = propTable,
				[4] = brushThick, -- brush thickness
				[5] = {
					['Color'] = true,
					['Material'] = true,
				}    
			}
			args[#args+1] = args2
		end

		for i = 1, #ObjTab do
			AddArgs(ObjTab[i])
		end
		
		args = {args}
		
		EditRems.Paint:FireServer(unpack(args))
		queueOver()
		return
	end)()
end

function BMod.paint2(ObjandPropTab, brushThick) --so yu can paint different things per block
	waitInQueue()
	coroutine.wrap(function()
		local args = {}
		local function AddArgs(Obj, propTable)
			local propTable = createProps(propTable, Obj)
			--for som reason it doesnt go past this
			local args2 = {
				[1] = Obj,
				[2] = Obj,
				[3] = propTable,
				[4] = unNil(brushThick, 1), -- brush thickness
				[5] = {
					['Color'] = true,
					['Material'] = true,
				}    
			}
			args[#args+1] = args2
		end

		for i = 1, #ObjandPropTab do
			AddArgs(ObjandPropTab[i][1], ObjandPropTab[i][2])
		end
		
		args = {args}
		EditRems.Paint:FireServer(unpack(args))
		queueOver()
		return
	end)()
end

function BMod.ClearWorld(deleteStarterblock, DisableWarn)
	local function BreakAll()
		if getgenv().getRank() == "Owner" then
			game:GetService("ReplicatedStorage").Sockets.World.LoadTemplate:FireServer("Scratch")
		else
			for _, obj in pairs(Blocks:GetChildren()) do
				BMod.delete(obj)
			end
		end
		if deleteStarterblock then
			Blocks:WaitForChild("Block", 1)
			if Blocks:FindFirstChild("Block") then
				BMod.delete(Blocks.Block)
			end			
		else
			BMod.place("0 0 0/0", {['Color'] = Color3.new(242, 243, 243)})
		end
	end
	if DisableWarn then BreakAll() return end
	local bind = Instance.new("BindableFunction")
	function bind.OnInvoke()
		BreakAll()
		bind:Destroy()
	end
	BMod.notify({
		Title = "Clear the world?",
		Text = "This includes all blocks and stats (wait 5 sec if you dont want to clear)",
		Button1 = "Confirm clearing world",
		Callback = bind,
		Duration = 3.8
	})
	task.wait(5)
	bind:Destroy()
	return
end

--[[ uhh dont worry about this

function BMod.Pixelate() --needs to be an image id
	local Image = require(somemodulelol)

	local brightnessArray = {}
	math.randomseed(tick())
	for i = 1, 100 do
		for j = 1, 100 do
			table.insert(brightnessArray, math.max(0, (math.noise(i/100, j/100) + 0.5) * 255))
		end
	end

	local img = Image.fromMonochrome(100, 100, brightnessArray)
	for i = 1, img.height do
		for j = 1, img.width do
			local index = (i - 1) * img.width + j
			local pixel = img.pixels[index]
			
			local p = Instance.new("Part")
			p.Anchored = true
			p.Size = Vector3.new(1, 1, 1)
			p.CFrame = CFrame.new(i, 10, j)
			p.Color = Color3.fromRGB(pixel, pixel, pixel)
			p.Material = Enum.Material.SmoothPlastic
			p.Parent = workspace
		end
		wait()
	end
end
]]

function BMod.callCommand(commandName, params)
	Rems.Command:InvokeServer('!'..commandName.." "..params)
end

function BMod.GamepassSerivce(itemID, bluxPrice, func)
	--working on later
end

function BMod.MarkPart() --u can use Part.Touched on the uniquely marked part
	--working on later
end

function BMod.SaveWorld(filename, exclusions) --only saves block type, placement, and texture
	if not filename then --look for an open savefile
		local Defaultname = "BlockateSave"
		local i = 0
		repeat
			filename = readfile(Defaultname..i)
		until not filename
		filename = Defaultname..i..".txt"
	end
    filename = filename..'.json'
    getgenv().debugOut('Saving world to '..filename)
	BMod.notify({Title = "Saving world..", Text = "World is being saved to file: "..filename..". Do not leave yet", Duration = 4})
	
	local function PackColor(color3)
		return {color3.R, color3.G, color3.B}
	end

	task.wait()
    local file = {['Blocks'] = {}}
    local Blocks = Blocks:GetChildren()
	for i, part in pairs(Blocks) do
		if i%120 == 0 then task.wait() end
		getgenv().debugOut(i)
		local posStr, props = CFToCFStr(part.CFrame), createProps(_, part)
		props.Color = PackColor(props.Color)
		props.LightColor = PackColor(props.LightColor)
		file.Blocks[#file.Blocks+1] = {posStr, props, {"--Debug--", "iter:"..tostring(i-1), "Orient: "..tostring(part.Orientation.X).." "..tostring(part.Orientation.Y).." "..tostring(part.Orientation.Z)}}
	end

    writefile(filename, HTTPServ:JSONEncode(file))
	getgenv().debugOut('Successfully saved world with '..#Blocks..' blocks to file: '..filename)
	BMod.notify({Title = "Save complete!", Text = "", Duration = 0.7})
end

function BMod.LoadWorld(filename, exclusions)
    local file = HTTPServ:JSONDecode(readfile(filename..'.json'))
    if not filename or not file then getgenv().debugOut("Provide a filename (file may be corrupted)") return end
    
	BMod.notify({Title = "Loading save", Text = filename.." is being loaded, this may take a while.", Duration = 4})
    
    filename = nil
	local function UnpackColor(tab)
		return Color3.new(tab[1], tab[2], tab[3])
	end

    local kicked = false
    local prompt = game:GetService("CoreGui"):FindFirstChild("RobloxPromptGui"):FindFirstChild("promptOverlay")
	prompt.DescendantAdded:Connect(function(Err)
		if UI.Name == "ErrorMessage" then
			UI:GetPropertyChangedSignal("Text"):Connect(function()
				kick = UI.Text
            end)
		end
	end)

    for i, data in pairs(file.Blocks) do
    	local block = data[2]
    	block.Color = UnpackColor(block.Color)
    	block.LightColor = UnpackColor(block.LightColor)
    	getgenv().debugOut(i)
    	table.foreach(block, getgenv().debugOut)
        BMod.place(data[1], block)
        task.wait()

        if kicked and kicked:sub() == "Sus" then  --i forgor whic 2 numbers were in sub, will do this later
            local Msg = "You were kicked upon placing block number ~"..tostring(i)..". Please keep your file "..filename.." and send it to the module developer for a fix"
            getgenv().debugOut(Msg)
            BMod.Notify(Msg)
        return end
    end
	getgenv().debugOut('Successfully loaded '..#file.Blocks..' blocks from file:'..filename)
	BMod.notify({Title = "Loading complete!", Text = "from file"..filename, Duration = 0.7})
	return
end

getgenv().debugOut('Successfully returned blockate module')
return BMod
--[[
Contributors
wrty (no github brueh)
this guy (https://github.com/philosolog)

]]
